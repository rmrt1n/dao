{
  "language": "Solidity",
  "sources": {
    "./contracts/IndividualDAO.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n// Uncomment this line to use console.log\nimport \"hardhat/console.sol\";\n\nimport \"@aragon/osx/framework/dao/DAOFactory.sol\";\nimport \"./AttestationStation.sol\";\n\n// Only the owner can change the constructor parameters\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title IndividualDAO\n/// @notice Custom DAOFactory for creating individual DAOs with selected plugins.\ncontract IndividualDAO is Ownable {\n    DAOFactory public daoFactory;\n    AttestationStation public attestationStationContract;\n    uint256 public minAttestations;\n\n    /// @param _daoFactoryAddress The address of the DAOFactory contract deployed on the network.\n    constructor(\n        address _daoFactoryAddress,\n        address _attestationStationProxy,\n        uint256 _minAttestations,\n    ) {\n        daoFactory = DAOFactory(_daoFactoryAddress);\n        attestationStationContract = AttestationStation(\n            _attestationStationProxy\n        );\n        minAttestations = _minAttestations;\n    }\n\n    //the modifier accepts an array of addresses, the salt used to get the DAO address, and the recovery key\n    modifier _isDAOAttested(\n        address[] _recoveryAccounts,\n        bytes32 _salt,\n        bytes32 _recoveryKey\n    ) {\n        //get the DAO address from the salt\n\n        //use a for loop to check each address in the array, and only use require statement if any false is found\n        for (uint256 i = 0; i < _recoveryAccounts.length; i++) {\n            //check if the address is attested\n            require(\n                attestationStationContract.attestations(\n                    _recoveryAccounts[i],\n                    _salt,\n                    _recoveryKey\n                ),\n                \"\n            );\n        }\n    }\n\n    function setAttestationStation(\n        address _attestationStation\n    ) external onlyOwner {\n        attestationStationContract = AttestationStation(_attestationStation);\n    }\n\n    function setMinAttestations(uint256 _minAttestations) external onlyOwner {\n        minAttestations = _minAttestations;\n    }\n\n    function setDAOFactory(address _daoFactoryAddress) external onlyOwner {\n        daoFactory = DAOFactory(_daoFactoryAddress);\n    }\n\n    /// @notice Creates a new DAO, registers it on the  DAO registry, and installs a list of plugins via the plugin setup processor.\n    /// @param _daoSettings The DAO settings to be set during the DAO initialization.\n    /// @param _pluginSettings The array containing references to plugins and their settings to be installed after the DAO has been created.\n    // function createDao(\n    //     DAOSettings calldata _daoSettings,\n    //     PluginSettings[] calldata _pluginSettings\n    // ) public override returns (DAO createdDao) {\n    //     // Check if no plugin is provided.\n    //     if (_pluginSettings.length == 0) {\n    //         revert NoPluginProvided();\n    //     }\n    //     // Create DAO.\n    //     createdDao = _createDAO(_daoSettings);\n    //     // Register DAO.\n    //     daoRegistry.register(createdDao, msg.sender, _daoSettings.subdomain);\n    //     // Get Permission IDs\n    //     bytes32 rootPermissionID = createdDao.ROOT_PERMISSION_ID();\n    //     bytes32 applyInstallationPermissionID = pluginSetupProcessor\n    //         .APPLY_INSTALLATION_PERMISSION_ID();\n    //     // Grant the temporary permissions.\n    //     // Grant Temporarly `ROOT_PERMISSION` to `pluginSetupProcessor`.\n    //     createdDao.grant(\n    //         address(createdDao),\n    //         address(pluginSetupProcessor),\n    //         rootPermissionID\n    //     );\n    //     // Grant Temporarly `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` to this `DAOFactory`.\n    //     createdDao.grant(\n    //         address(pluginSetupProcessor),\n    //         address(this),\n    //         applyInstallationPermissionID\n    //     );\n    //     // Install plugins on the newly created DAO.\n    //     for (uint256 i; i < _pluginSettings.length; ++i) {\n    //         // Prepare plugin.\n    //         (\n    //             address plugin,\n    //             IPluginSetup.PreparedSetupData memory preparedSetupData\n    //         ) = pluginSetupProcessor.prepareInstallation(\n    //                 address(createdDao),\n    //                 PluginSetupProcessor.PrepareInstallationParams(\n    //                     _pluginSettings[i].pluginSetupRef,\n    //                     _pluginSettings[i].data\n    //                 )\n    //             );\n    //         // Apply plugin.\n    //         pluginSetupProcessor.applyInstallation(\n    //             address(createdDao),\n    //             PluginSetupProcessor.ApplyInstallationParams(\n    //                 _pluginSettings[i].pluginSetupRef,\n    //                 plugin,\n    //                 preparedSetupData.permissions,\n    //                 hashHelpers(preparedSetupData.helpers)\n    //             )\n    //         );\n    //     }\n    //     // Set the rest of DAO's permissions.\n    //     _setDAOPermissions(createdDao);\n    //     // Revoke the temporarly granted permissions.\n    //     // Revoke Temporarly `ROOT_PERMISSION` from `pluginSetupProcessor`.\n    //     createdDao.revoke(\n    //         address(createdDao),\n    //         address(pluginSetupProcessor),\n    //         rootPermissionID\n    //     );\n    //     // Revoke `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` from this `DAOFactory` .\n    //     createdDao.revoke(\n    //         address(pluginSetupProcessor),\n    //         address(this),\n    //         applyInstallationPermissionID\n    //     );\n    //     // Revoke Temporarly `ROOT_PERMISSION_ID` from `pluginSetupProcessor` that implecitly granted to this `DaoFactory`\n    //     // at the create dao step `address(this)` being the initial owner of the new created DAO.\n    //     createdDao.revoke(address(createdDao), address(this), rootPermissionID);\n    // }\n}\n"
    },
    "./contracts/AttestationStation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ncontract AttestationStation {\n    /**\n     * @notice Maps addresses to attestations. Creator => About => Key => Value.\n     */\n    mapping(address => mapping(address => mapping(bytes32 => bytes)))\n        public attestations;\n\n    /**\n     * @notice Struct representing data that is being attested.\n     *\n     * @custom:field creator Address that made the attestation.\n     * @custom:field about Address for which the attestation is about.\n     * @custom:field key   A bytes32 key for the attestation.\n     * @custom:field val   The attestation as arbitrary bytes.\n     */\n    struct AttestationData {\n        address creator;\n        address about;\n        bytes32 key;\n        bytes val;\n    }\n\n    /**\n     * @notice Emitted when Attestation is created.\n     *\n     * @param creator Address that made the attestation.\n     * @param about   Address attestation is about.\n     * @param key     Key of the attestation.\n     * @param val     Value of the attestation.\n     */\n    event AttestationCreated(\n        address indexed creator,\n        address indexed about,\n        bytes32 indexed key,\n        bytes val\n    );\n\n    /**\n     * @notice Allows anyone to create an attestation.\n     *\n     * @param _creator Address that the attestation is about.\n     * @param _about Address that the attestation is about.\n     * @param _key   A key used to namespace the attestation.\n     * @param _val   An arbitrary value stored as part of the attestation.\n     */\n    function attestOne(\n        address _creator,\n        address _about,\n        bytes32 _key,\n        bytes memory _val\n    ) public {\n        attestations[_creator][_about][_key] = _val;\n        emit AttestationCreated(_creator, _about, _key, _val);\n    }\n\n    /**\n     * @notice Allows anyone to create attestations.\n     *\n     * @param _attestations An array of attestation data.\n     */\n    function attest(AttestationData[] calldata _attestations) external {\n        uint256 length = _attestations.length;\n        for (uint256 i = 0; i < length; ) {\n            AttestationData memory attestation = _attestations[i];\n\n            attestOne(\n                attestation.creator,\n                attestation.about,\n                attestation.key,\n                attestation.val\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "./contracts/AttestationStationProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/**\n * @title AttestationStationProxy\n * @notice AttestationStationProxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract AttestationStationProxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) external proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(\n        address _implementation,\n        bytes calldata _data\n    ) external payable proxyCallIfNotAdmin returns (bytes memory) {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(\n            _data\n        );\n        require(\n            success,\n            \"Proxy: delegatecall to new implementation contract failed\"\n        );\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) external proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() external proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() external proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(\n                gas(),\n                impl,\n                0x0,\n                calldatasize(),\n                0x0,\n                0x0\n            )\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "./contracts/NFTGovernance.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\r\nimport {IDAO, DAO} from '@aragon/osx/core/dao/DAO.sol';\r\n//import {PluginCloneable, IDAO} from '@aragon/osx/core/plugin/PluginCloneable.sol';\r\n\r\n\r\ncontract NFTGovernance is Initializable,ERC721Upgradeable, AccessControlEnumerableUpgradeable{\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\r\n    //using Address for address;\r\n    address public governance;\r\n    address public admin;\r\n    uint256 public _tokenID;\r\n    uint256 public _minApprovals;\r\n    uint256 private _proposalCount;\r\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\r\n    bytes32 public constant VOTER_ROLE = keccak256(\"VOTER_ROLE\");\r\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\r\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\r\n    bytes32 public constant ADMIN_EXECUTE_PERMISSION_ID = keccak256('ADMIN_EXECUTE_PERMISSION');\r\n\r\n    mapping(address=>bool) public WhiteList;\r\n    mapping(uint256 => Proposal) private _proposals;\r\n    mapping(bytes32 => bool) private _proposalExists;\r\n\r\n    struct Proposal {\r\n    bool exists;\r\n    bool executed;\r\n    bool canceled;\r\n    uint256 id;\r\n    uint256 proposalTime;\r\n    uint256 approvalCount;\r\n    address proposer;\r\n    address target;\r\n    string proposalHash;\r\n    string description;\r\n    bytes data;\r\n    mapping(address => bool) approvals;\r\n    mapping(address =>bool) voters;\r\n    }\r\n\r\n\r\n\r\n\r\n    event ProposalApproval(uint256 indexed proposalId, address indexed approver);\r\n    event ProposalExecutionFailure(uint256 indexed proposalId, address target, bytes data, bytes result);\r\n    event ProposalExecution(uint256 indexed proposalId, address target, bytes data, bytes result);\r\n    event ProposalSubmission(uint256 indexed proposalId, address indexed proposer, address indexed target, bytes data, string description);\r\n    event ProposalVote(uint256 indexed proposalId,uint256 indexed tokenId, address indexed target);\r\n    event ProposalCancled(uint256 indexed proposalId);\r\n\r\n\r\n    //function initialize(IDAO _dao, address _admin) external initializer{\r\n    //     __PluginCloneable_init(_dao);\r\n    //     //TODO: change the governance address to admin address\r\n    //     admin = _admin;\r\n    // }\r\n    function initialize(IDAO _dao, address _admin) public initializer {\r\n        __ERC721_init(\"NFT Governance Token\", \"NFTGT\");\r\n        __AccessControlEnumerable_init();\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setupRole(OPERATOR_ROLE, msg.sender);\r\n    }\r\n    //constructor(string memory name, string memory symbol) ERC721(name,symbol){}\r\n\r\n     \r\n    // Set the NFT that is going to be used as governance for the DAO\r\n    //TODO Might add an only owner modifier later\r\n    //2 ways pre deploy the memberhip NFT then add the contract address\r\n    function setGovernance(address nftcontract, uint256 tokenID) external{\r\n        require(nftcontract !=address(0),\"NFT contract cannot be zero\");\r\n        //remove this 2 require statements if u want to test this function. ONLY REMOVE FOR TESTING IT Works once its implemented\r\n        //require(isContract(nftcontract),\"Not a contract\");\r\n        //require(ERC721(nftcontract).ownerOf(tokenID) == address(this), \"NFT is not owned by the contract\");\r\n        governance = nftcontract;\r\n        _tokenID = tokenID;\r\n    }\r\n\r\n    //set Access Controll List and set the WhiteList mapping to true for each address\r\n    //TODO add onlyOwner modifier later\r\n   function setGovernanceACL(\r\n        address _governanceContract, \r\n        address[] calldata _proposers, \r\n        address[] calldata _voters, \r\n        address[] calldata _executors\r\n    ) external {\r\n        //require(_governanceContract != address(0), \"NFT contract cannot be zero\");\r\n        require(_proposers.length > 0, \"At least one proposer is required\");\r\n        require(_voters.length > 0, \"At least one voter is required\");\r\n        require(_executors.length > 0, \"At least one executor is required\");\r\n        \r\n        //set governance contract \r\n        governance = _governanceContract;\r\n\r\n        //assign roles to proposers,voters,executers\r\n\r\n        for(uint256 i;i<_proposers.length;++i){\r\n            _setupRole(PROPOSER_ROLE, _proposers[i]);\r\n            WhiteList[_proposers[i]] = true;\r\n        }\r\n\r\n        for(uint256 i; i<_voters.length;++i){\r\n            _setupRole(VOTER_ROLE, _voters[i]);\r\n            WhiteList[_voters[i]] = true;\r\n\r\n        }\r\n\r\n        for (uint256 i; i < _executors.length; ++i) {\r\n            _setupRole(EXECUTOR_ROLE, _executors[i]);\r\n            WhiteList[_executors[i]] = true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    //function to create new proposals in the governance contract.\r\n    function propose(\r\n        address target,\r\n        bytes memory data,\r\n        string memory proposalHash,\r\n        string memory description\r\n    ) external returns (uint256) {\r\n        require(WhiteList[msg.sender], \"Sender not in whitelist\");\r\n        require(hasRole(PROPOSER_ROLE, governance), \"Does not have proposer role\");\r\n\r\n        bytes32 hash = keccak256(abi.encode(target, data, proposalHash, block.number));\r\n        require(!_proposalExists[hash], \"Identical proposal already exists\");\r\n\r\n        uint256 proposalId = ++_proposalCount;\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        proposal.id = proposalId;\r\n        proposal.proposer = msg.sender;\r\n        proposal.target = target;\r\n        proposal.data = data;\r\n        proposal.proposalHash = proposalHash;\r\n        proposal.description = description;\r\n        proposal.exists = true;\r\n        proposal.executed = false;\r\n        proposal.canceled = false;\r\n        proposal.approvalCount = 0;\r\n\r\n        _proposalExists[hash] = true;\r\n\r\n        emit ProposalSubmission(proposalId, msg.sender, target, data, description);\r\n\r\n        return proposalId;\r\n    }\r\n\r\n\r\n\r\n    //used to approved proposals by their ID\r\n    function approve(uint256 proposalId) external {\r\n        require(WhiteList[msg.sender], \"Sender not in whitelist\");\r\n        require(hasRole(PROPOSER_ROLE, governance), \"Does not have proposer role\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(!proposal.executed, \"Proposal has already been executed\");\r\n        require(!proposal.canceled, \"Proposal has been canceled\");\r\n\r\n        proposal.approvals[msg.sender] = true;\r\n        proposal.approvalCount++;\r\n\r\n        emit ProposalApproval(proposalId, msg.sender);\r\n    }\r\n\r\n    //usrs with executer role can execute a proposal if threshold has been meet or if it gets enough approvals\r\n    function execute(uint256 proposalId) external {\r\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"Caller is not an executor\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(proposal.approvalCount >= _minApprovals, \"Proposal has not met minimum approvals\");\r\n        require(!proposal.executed, \"Proposal has already been executed\");\r\n        require(!proposal.canceled, \"Proposal has been canceled\");\r\n\r\n        proposal.executed = true;\r\n\r\n        bool success;\r\n        bytes memory result;\r\n        (success, result) = proposal.target.call(proposal.data);\r\n\r\n        if (success) {\r\n            emit ProposalExecution(proposalId, proposal.target, proposal.data, result);\r\n        } else {\r\n            emit ProposalExecutionFailure(proposalId, proposal.target, proposal.data, result);\r\n            proposal.executed = false;\r\n        }\r\n    }\r\n    \r\n    //Function to cancle the proposal by the proposer\r\n    function cancleProposal(uint256 proposalId) public{\r\n        require(_proposals[proposalId].exists,\"Invalid proposal ID\");\r\n        require(_proposals[proposalId].proposer == msg.sender,\"Only the proposer can cancle\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(!proposal.executed && !proposal.canceled, \"Proposal has been cancled or executed\");\r\n\r\n        proposal.canceled = true;\r\n\r\n        emit ProposalCancled(proposalId);\r\n    }\r\n\r\n    function vote(uint256 proposalId, uint256 tokenId) external{\r\n        require(_proposals[proposalId].exists,\"Invalid proposal ID\");\r\n        require(!_proposals[proposalId].executed,\"Proposal already executed\");\r\n        require(!_proposals[proposalId].canceled,\"Proposal already cancled\");\r\n        require(ownerOf(tokenId) == msg.sender,\"Only NFT owner can vote\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(!proposal.voters[msg.sender], \"Already voted\");\r\n\r\n        proposal.voters[msg.sender] = true;\r\n        proposal.approvalCount++;\r\n\r\n        emit ProposalVote(proposalId, tokenId, msg.sender);\r\n\r\n\r\n    }\r\n\r\n    //returns an array of proposal IDS that is used to retrive the poposals from strogae\r\n    //Did this way coz didnt want to change the voters mapping to an array\r\n    function getProposals() public view returns (uint256[] memory) {\r\n        uint256[] memory proposalIds = new uint256[](_proposalCount);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 1; i <= _proposalCount; i++) {\r\n            if (_proposals[i].exists) {\r\n                proposalIds[count] = i;\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Resize the array to remove unused elements\r\n        assembly {\r\n            mstore(proposalIds, count)\r\n        }\r\n\r\n        return proposalIds;\r\n    }\r\n\r\n    //TODO add an onlyOwner or onlyAdmin modifier\r\n    // //There is some errors here that got me scratching my head\r\n    // function setQuorum(uint256 _proposalId, uint256 _percentage) external {\r\n    //     Proposal storage proposal = _proposals[_proposalId];\r\n    //     require(proposal.exists, \"Proposal does not exist\");\r\n\r\n    //     uint256 totalVoters = 0;\r\n    //     uint256 numApprovals = proposal.approvalCount;\r\n    //     for (uint256 i = 0; i < numApprovals; i++) {\r\n    //         address voter = proposal.approvals[i];\r\n    //         if (proposal.voters[voter]) {\r\n    //             totalVoters++;\r\n    //         }\r\n    //     }\r\n\r\n    //     uint256 totalSupply = 20;//IERC721(NFTGovernance).totalSupply();\r\n    //     uint256 requiredVoters = (totalSupply * _percentage) / 100;\r\n    //     require(totalVoters >= requiredVoters, \"Quorum not reached\");\r\n\r\n    //     //proposal.quorum = _percentage;\r\n    // }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    //assembly to check if the given address is a contract. Used assembly coz it saves some gas\r\n    function isContract(address _addr) internal view returns (bool){\r\n        uint256 size;\r\n        assembly{\r\n            size:=extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    // function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, AccessControl, PluginCloneable) returns (bool) {\r\n    //     return super.supportsInterface(interfaceId);\r\n    // }\r\n\r\n    function _msgSender() internal view override(ContextUpgradeable) returns (address) {\r\n        return super._msgSender();\r\n    }\r\n\r\n    function _msgData() internal view override(ContextUpgradeable) returns (bytes calldata) {\r\n        return super._msgData();\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721Upgradeable, AccessControlEnumerableUpgradeable) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n\r\n\r\n}"
    },
    "./contracts/AttestationProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n// To verify signatures\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// Only the owner can change the attestation station\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IAttestationStation {\n    struct AttestationData {\n        address creator;\n        address about;\n        bytes32 key;\n        bytes val;\n    }\n\n    event AttestationCreated(\n        address indexed creator,\n        address indexed about,\n        bytes32 indexed key,\n        bytes val\n    );\n\n    function attest(AttestationData[] memory _attestations) external;\n}\n\ncontract AttestationProxy is Ownable {\n    using ECDSA for bytes32;\n\n    /// @dev The interface for OP's Attestation Station.\n    IAttestationStation public attestationStation;\n\n    constructor(address _attestationStation) {\n        attestationStation = IAttestationStation(_attestationStation);\n    }\n\n    /**\n     * @notice Allows the owner to change the AttestationStation implementation.\n     * @param _attestationStation The address of the new AttestationStation implementation.\n     *\n     * Requirements:\n     * - The caller must be the current owner.\n     */\n    function setAttestationStation(\n        address _attestationStation\n    ) public onlyOwner {\n        attestationStation = IAttestationStation(_attestationStation);\n    }\n\n    /**\n     * @notice Attest data\n     * @param _about The address of the account to be attested.\n     * @param _key The key of the attestation.\n     * @param _val The value of the attestation.\n     * @param _signature The signature of the attestation.\n     */\n    function attest(\n        address _about,\n        bytes32 _key,\n        bytes memory _val,\n        bytes memory _signature\n    ) public {\n        bool pass = _verifySignature(_about, _key, _val, _signature);\n\n        require(pass, \"AttestationProxy: Invalid signature\");\n\n        // Send the attestation to the Attestation Station.\n        IAttestationStation.AttestationData[]\n            memory attestation = new IAttestationStation.AttestationData[](1);\n        attestation[0] = IAttestationStation.AttestationData({\n            creator: msg.sender,\n            about: _about,\n            key: _key,\n            val: _val\n        });\n        attestationStation.attest(attestation);\n    }\n\n    /**\n     * @notice Verifies the attestation data before calling the OP AttestationStation attest.\n     * @param _about The address of the account to be attested.\n     * @param _key The key of the attestation.\n     * @param _val The value of the attestation.\n     * @param _signature The signer's signed message of the attestation.\n     *\n     * Requirements:\n     * - The signature must resolve to the msg.sender.\n     */\n    function _verifySignature(\n        address _about,\n        bytes32 _key,\n        bytes memory _val,\n        bytes memory _signature\n    ) internal view returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(_about, _key, _val));\n\n        return (messageHash.toEthSignedMessageHash().recover(_signature) ==\n            msg.sender);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     *\n     * @param _newOwner The address of the new owner.\n     *\n     * Requirements:\n     * - The caller must be the current owner.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner {\n        super.transferOwnership(_newOwner);\n    }\n}\n"
    },
    "./contracts/NFTGovernanceSetup.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\r\n\r\nimport {PermissionLib} from '@aragon/osx/core/permission/PermissionLib.sol';\r\nimport {PluginSetup, IPluginSetup} from '@aragon/osx/framework/plugin/setup/PluginSetup.sol';\r\n\r\nimport {NFTGovernance} from './NFTGovernance.sol';\r\nimport {IDAO, DAO} from '@aragon/osx/core/dao/DAO.sol';\r\n\r\ncontract nfgGovernanceSetup is PluginSetup{\r\n    using Clones for address;\r\n\r\n    address private immutable NFTGovernanceImplementation;\r\n\r\n    constructor(){\r\n        NFTGovernanceImplementation = address(new NFTGovernance());\r\n    }\r\n\r\n    function prepareInstallation(\r\n        address _dao,\r\n        bytes calldata _data\r\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData) {\r\n        // Decode `_data` to extract the params needed for cloning and initializing `Admin` plugin.\r\n        address admin = abi.decode(_data, (address));\r\n\r\n        // Clone plugin contract.\r\n        plugin = NFTGovernanceImplementation.clone();\r\n\r\n        // Initialize cloned plugin contract.\r\n        NFTGovernance(plugin).initialize(IDAO(_dao), admin);\r\n\r\n        // Prepare permissions\r\n        PermissionLib.MultiTargetPermission[]\r\n        memory permissions = new PermissionLib.MultiTargetPermission[](2);\r\n\r\n        // Grant the `ADMIN_EXECUTE_PERMISSION` of the Plugin to the admin.\r\n        permissions[0] = PermissionLib.MultiTargetPermission({\r\n        operation: PermissionLib.Operation.Grant,\r\n        where: plugin,\r\n        who: admin,\r\n        condition: PermissionLib.NO_CONDITION,\r\n        permissionId: NFTGovernance(plugin).ADMIN_EXECUTE_PERMISSION_ID()\r\n        });\r\n\r\n        // Grant the `EXECUTE_PERMISSION` on the DAO to the plugin.\r\n        permissions[1] = PermissionLib.MultiTargetPermission({\r\n        operation: PermissionLib.Operation.Grant,\r\n        where: _dao,\r\n        who: plugin,\r\n        condition: PermissionLib.NO_CONDITION,\r\n        permissionId: DAO(payable(_dao)).EXECUTE_PERMISSION_ID()\r\n        });\r\n\r\n        preparedSetupData.permissions = permissions;\r\n    }\r\n\r\n    /// @inheritdoc IPluginSetup\r\n    function prepareUninstallation(\r\n        address _dao,\r\n        SetupPayload calldata _payload\r\n    ) external view returns (PermissionLib.MultiTargetPermission[] memory permissions) {\r\n        // Collect addresses\r\n        address plugin = _payload.plugin;\r\n        address admin = NFTGovernance(plugin).admin();\r\n\r\n        // Prepare permissions\r\n        permissions = new PermissionLib.MultiTargetPermission[](2);\r\n\r\n        permissions[0] = PermissionLib.MultiTargetPermission({\r\n        operation: PermissionLib.Operation.Revoke,\r\n        where: plugin,\r\n        who: admin,\r\n        condition: PermissionLib.NO_CONDITION,\r\n        permissionId: NFTGovernance(plugin).ADMIN_EXECUTE_PERMISSION_ID()\r\n        });\r\n\r\n        permissions[1] = PermissionLib.MultiTargetPermission({\r\n        operation: PermissionLib.Operation.Revoke,\r\n        where: _dao,\r\n        who: plugin,\r\n        condition: PermissionLib.NO_CONDITION,\r\n        permissionId: DAO(payable(_dao)).EXECUTE_PERMISSION_ID()\r\n        });\r\n    }\r\n      /// @inheritdoc IPluginSetup\r\n  function implementation() external view returns (address) {\r\n    return NFTGovernanceImplementation;\r\n  }\r\n}"
    },
    "./contracts/NFTGovernance.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\r\nimport {IDAO, DAO} from '@aragon/osx/core/dao/DAO.sol';\r\n//import {PluginCloneable, IDAO} from '@aragon/osx/core/plugin/PluginCloneable.sol';\r\n\r\n\r\ncontract NFTGovernance is Initializable,ERC721Upgradeable, AccessControlEnumerableUpgradeable{\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\r\n    //using Address for address;\r\n    address public governance;\r\n    address public admin;\r\n    uint256 public _tokenID;\r\n    uint256 public _minApprovals;\r\n    uint256 private _proposalCount;\r\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\r\n    bytes32 public constant VOTER_ROLE = keccak256(\"VOTER_ROLE\");\r\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\r\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\r\n    bytes32 public constant ADMIN_EXECUTE_PERMISSION_ID = keccak256('ADMIN_EXECUTE_PERMISSION');\r\n\r\n    mapping(address=>bool) public WhiteList;\r\n    mapping(uint256 => Proposal) private _proposals;\r\n    mapping(bytes32 => bool) private _proposalExists;\r\n\r\n    struct Proposal {\r\n    bool exists;\r\n    bool executed;\r\n    bool canceled;\r\n    uint256 id;\r\n    uint256 proposalTime;\r\n    uint256 approvalCount;\r\n    address proposer;\r\n    address target;\r\n    string proposalHash;\r\n    string description;\r\n    bytes data;\r\n    mapping(address => bool) approvals;\r\n    mapping(address =>bool) voters;\r\n    }\r\n\r\n\r\n\r\n\r\n    event ProposalApproval(uint256 indexed proposalId, address indexed approver);\r\n    event ProposalExecutionFailure(uint256 indexed proposalId, address target, bytes data, bytes result);\r\n    event ProposalExecution(uint256 indexed proposalId, address target, bytes data, bytes result);\r\n    event ProposalSubmission(uint256 indexed proposalId, address indexed proposer, address indexed target, bytes data, string description);\r\n    event ProposalVote(uint256 indexed proposalId,uint256 indexed tokenId, address indexed target);\r\n    event ProposalCancled(uint256 indexed proposalId);\r\n\r\n\r\n    //function initialize(IDAO _dao, address _admin) external initializer{\r\n    //     __PluginCloneable_init(_dao);\r\n    //     //TODO: change the governance address to admin address\r\n    //     admin = _admin;\r\n    // }\r\n    function initialize(IDAO _dao, address _admin) public initializer {\r\n        __ERC721_init(\"NFT Governance Token\", \"NFTGT\");\r\n        __AccessControlEnumerable_init();\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setupRole(OPERATOR_ROLE, msg.sender);\r\n    }\r\n    //constructor(string memory name, string memory symbol) ERC721(name,symbol){}\r\n\r\n     \r\n    // Set the NFT that is going to be used as governance for the DAO\r\n    //TODO Might add an only owner modifier later\r\n    //2 ways pre deploy the memberhip NFT then add the contract address\r\n    function setGovernance(address nftcontract, uint256 tokenID) external{\r\n        require(nftcontract !=address(0),\"NFT contract cannot be zero\");\r\n        //remove this 2 require statements if u want to test this function. ONLY REMOVE FOR TESTING IT Works once its implemented\r\n        //require(isContract(nftcontract),\"Not a contract\");\r\n        //require(ERC721(nftcontract).ownerOf(tokenID) == address(this), \"NFT is not owned by the contract\");\r\n        governance = nftcontract;\r\n        _tokenID = tokenID;\r\n    }\r\n\r\n    //set Access Controll List and set the WhiteList mapping to true for each address\r\n    //TODO add onlyOwner modifier later\r\n   function setGovernanceACL(\r\n        address _governanceContract, \r\n        address[] calldata _proposers, \r\n        address[] calldata _voters, \r\n        address[] calldata _executors\r\n    ) external {\r\n        //require(_governanceContract != address(0), \"NFT contract cannot be zero\");\r\n        require(_proposers.length > 0, \"At least one proposer is required\");\r\n        require(_voters.length > 0, \"At least one voter is required\");\r\n        require(_executors.length > 0, \"At least one executor is required\");\r\n        \r\n        //set governance contract \r\n        governance = _governanceContract;\r\n\r\n        //assign roles to proposers,voters,executers\r\n\r\n        for(uint256 i;i<_proposers.length;++i){\r\n            _setupRole(PROPOSER_ROLE, _proposers[i]);\r\n            WhiteList[_proposers[i]] = true;\r\n        }\r\n\r\n        for(uint256 i; i<_voters.length;++i){\r\n            _setupRole(VOTER_ROLE, _voters[i]);\r\n            WhiteList[_voters[i]] = true;\r\n\r\n        }\r\n\r\n        for (uint256 i; i < _executors.length; ++i) {\r\n            _setupRole(EXECUTOR_ROLE, _executors[i]);\r\n            WhiteList[_executors[i]] = true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    //function to create new proposals in the governance contract.\r\n    function propose(\r\n        address target,\r\n        bytes memory data,\r\n        string memory proposalHash,\r\n        string memory description\r\n    ) external returns (uint256) {\r\n        require(WhiteList[msg.sender], \"Sender not in whitelist\");\r\n        require(hasRole(PROPOSER_ROLE, governance), \"Does not have proposer role\");\r\n\r\n        bytes32 hash = keccak256(abi.encode(target, data, proposalHash, block.number));\r\n        require(!_proposalExists[hash], \"Identical proposal already exists\");\r\n\r\n        uint256 proposalId = ++_proposalCount;\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        proposal.id = proposalId;\r\n        proposal.proposer = msg.sender;\r\n        proposal.target = target;\r\n        proposal.data = data;\r\n        proposal.proposalHash = proposalHash;\r\n        proposal.description = description;\r\n        proposal.exists = true;\r\n        proposal.executed = false;\r\n        proposal.canceled = false;\r\n        proposal.approvalCount = 0;\r\n\r\n        _proposalExists[hash] = true;\r\n\r\n        emit ProposalSubmission(proposalId, msg.sender, target, data, description);\r\n\r\n        return proposalId;\r\n    }\r\n\r\n\r\n\r\n    //used to approved proposals by their ID\r\n    function approve(uint256 proposalId) external {\r\n        require(WhiteList[msg.sender], \"Sender not in whitelist\");\r\n        require(hasRole(PROPOSER_ROLE, governance), \"Does not have proposer role\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(!proposal.executed, \"Proposal has already been executed\");\r\n        require(!proposal.canceled, \"Proposal has been canceled\");\r\n\r\n        proposal.approvals[msg.sender] = true;\r\n        proposal.approvalCount++;\r\n\r\n        emit ProposalApproval(proposalId, msg.sender);\r\n    }\r\n\r\n    //usrs with executer role can execute a proposal if threshold has been meet or if it gets enough approvals\r\n    function execute(uint256 proposalId) external {\r\n        require(hasRole(EXECUTOR_ROLE, msg.sender), \"Caller is not an executor\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(proposal.exists, \"Proposal does not exist\");\r\n        require(proposal.approvalCount >= _minApprovals, \"Proposal has not met minimum approvals\");\r\n        require(!proposal.executed, \"Proposal has already been executed\");\r\n        require(!proposal.canceled, \"Proposal has been canceled\");\r\n\r\n        proposal.executed = true;\r\n\r\n        bool success;\r\n        bytes memory result;\r\n        (success, result) = proposal.target.call(proposal.data);\r\n\r\n        if (success) {\r\n            emit ProposalExecution(proposalId, proposal.target, proposal.data, result);\r\n        } else {\r\n            emit ProposalExecutionFailure(proposalId, proposal.target, proposal.data, result);\r\n            proposal.executed = false;\r\n        }\r\n    }\r\n    \r\n    //Function to cancle the proposal by the proposer\r\n    function cancleProposal(uint256 proposalId) public{\r\n        require(_proposals[proposalId].exists,\"Invalid proposal ID\");\r\n        require(_proposals[proposalId].proposer == msg.sender,\"Only the proposer can cancle\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(!proposal.executed && !proposal.canceled, \"Proposal has been cancled or executed\");\r\n\r\n        proposal.canceled = true;\r\n\r\n        emit ProposalCancled(proposalId);\r\n    }\r\n\r\n    function vote(uint256 proposalId, uint256 tokenId) external{\r\n        require(_proposals[proposalId].exists,\"Invalid proposal ID\");\r\n        require(!_proposals[proposalId].executed,\"Proposal already executed\");\r\n        require(!_proposals[proposalId].canceled,\"Proposal already cancled\");\r\n        require(ownerOf(tokenId) == msg.sender,\"Only NFT owner can vote\");\r\n\r\n        Proposal storage proposal = _proposals[proposalId];\r\n        require(!proposal.voters[msg.sender], \"Already voted\");\r\n\r\n        proposal.voters[msg.sender] = true;\r\n        proposal.approvalCount++;\r\n\r\n        emit ProposalVote(proposalId, tokenId, msg.sender);\r\n\r\n\r\n    }\r\n\r\n    //returns an array of proposal IDS that is used to retrive the poposals from strogae\r\n    //Did this way coz didnt want to change the voters mapping to an array\r\n    function getProposals() public view returns (uint256[] memory) {\r\n        uint256[] memory proposalIds = new uint256[](_proposalCount);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 1; i <= _proposalCount; i++) {\r\n            if (_proposals[i].exists) {\r\n                proposalIds[count] = i;\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Resize the array to remove unused elements\r\n        assembly {\r\n            mstore(proposalIds, count)\r\n        }\r\n\r\n        return proposalIds;\r\n    }\r\n\r\n    //TODO add an onlyOwner or onlyAdmin modifier\r\n    // //There is some errors here that got me scratching my head\r\n    // function setQuorum(uint256 _proposalId, uint256 _percentage) external {\r\n    //     Proposal storage proposal = _proposals[_proposalId];\r\n    //     require(proposal.exists, \"Proposal does not exist\");\r\n\r\n    //     uint256 totalVoters = 0;\r\n    //     uint256 numApprovals = proposal.approvalCount;\r\n    //     for (uint256 i = 0; i < numApprovals; i++) {\r\n    //         address voter = proposal.approvals[i];\r\n    //         if (proposal.voters[voter]) {\r\n    //             totalVoters++;\r\n    //         }\r\n    //     }\r\n\r\n    //     uint256 totalSupply = 20;//IERC721(NFTGovernance).totalSupply();\r\n    //     uint256 requiredVoters = (totalSupply * _percentage) / 100;\r\n    //     require(totalVoters >= requiredVoters, \"Quorum not reached\");\r\n\r\n    //     //proposal.quorum = _percentage;\r\n    // }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    //assembly to check if the given address is a contract. Used assembly coz it saves some gas\r\n    function isContract(address _addr) internal view returns (bool){\r\n        uint256 size;\r\n        assembly{\r\n            size:=extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    // function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, AccessControl, PluginCloneable) returns (bool) {\r\n    //     return super.supportsInterface(interfaceId);\r\n    // }\r\n\r\n    function _msgSender() internal view override(ContextUpgradeable) returns (address) {\r\n        return super._msgSender();\r\n    }\r\n\r\n    function _msgData() internal view override(ContextUpgradeable) returns (bytes calldata) {\r\n        return super._msgData();\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721Upgradeable, AccessControlEnumerableUpgradeable) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n\r\n\r\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@aragon/osx/framework/dao/DAOFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {DAO} from \"../../core/dao/DAO.sol\";\nimport {PermissionLib} from \"../../core/permission/PermissionLib.sol\";\nimport {createERC1967Proxy} from \"../../utils/Proxy.sol\";\nimport {PluginRepo} from \"../plugin/repo/PluginRepo.sol\";\nimport {PluginSetupProcessor} from \"../plugin/setup/PluginSetupProcessor.sol\";\nimport {hashHelpers, PluginSetupRef} from \"../plugin/setup/PluginSetupProcessorHelpers.sol\";\nimport {IPluginSetup} from \"../plugin/setup/IPluginSetup.sol\";\nimport {DAORegistry} from \"./DAORegistry.sol\";\n\n/// @title DAOFactory\n/// @author Aragon Association - 2022-2023\n/// @notice This contract is used to create a DAO.\ncontract DAOFactory {\n    /// @notice The DAO base contract, to be used for creating new `DAO`s via `createERC1967Proxy` function.\n    address public immutable daoBase;\n\n    /// @notice The DAO registry listing the `DAO` contracts created via this contract.\n    DAORegistry public immutable daoRegistry;\n\n    /// @notice The plugin setup processor for installing plugins on the newly created `DAO`s.\n    PluginSetupProcessor public immutable pluginSetupProcessor;\n\n    /// @notice The container for the DAO settings to be set during the DAO initialization.\n    /// @param trustedForwarder The address of the trusted forwarder required for meta transactions.\n    /// @param daoURI The DAO uri used with [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824).\n    /// @param subdomain The ENS subdomain to be registered for the DAO contract.\n    /// @param metadata The metadata of the DAO.\n    struct DAOSettings {\n        address trustedForwarder;\n        string daoURI;\n        string subdomain;\n        bytes metadata;\n    }\n\n    /// @notice The container with the information required to install a plugin on the DAO.\n    /// @param pluginSetupRef The `PluginSetupRepo` address of the plugin and the version tag.\n    /// @param data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\n    struct PluginSettings {\n        PluginSetupRef pluginSetupRef;\n        bytes data;\n    }\n\n    /// @notice Thrown if `PluginSettings` array is empty, and no plugin is provided.\n    error NoPluginProvided();\n\n    /// @notice The constructor setting the registry and plugin setup processor and creating the base contracts for the factory.\n    /// @param _registry The DAO registry to register the DAO by its name.\n    /// @param _pluginSetupProcessor The address of PluginSetupProcessor.\n    constructor(DAORegistry _registry, PluginSetupProcessor _pluginSetupProcessor) {\n        daoRegistry = _registry;\n        pluginSetupProcessor = _pluginSetupProcessor;\n\n        daoBase = address(new DAO());\n    }\n\n    /// @notice Creates a new DAO, registers it on the  DAO registry, and installs a list of plugins via the plugin setup processor.\n    /// @param _daoSettings The DAO settings to be set during the DAO initialization.\n    /// @param _pluginSettings The array containing references to plugins and their settings to be installed after the DAO has been created.\n    function createDao(\n        DAOSettings calldata _daoSettings,\n        PluginSettings[] calldata _pluginSettings\n    ) external returns (DAO createdDao) {\n        // Check if no plugin is provided.\n        if (_pluginSettings.length == 0) {\n            revert NoPluginProvided();\n        }\n\n        // Create DAO.\n        createdDao = _createDAO(_daoSettings);\n\n        // Register DAO.\n        daoRegistry.register(createdDao, msg.sender, _daoSettings.subdomain);\n\n        // Get Permission IDs\n        bytes32 rootPermissionID = createdDao.ROOT_PERMISSION_ID();\n        bytes32 applyInstallationPermissionID = pluginSetupProcessor\n            .APPLY_INSTALLATION_PERMISSION_ID();\n\n        // Grant the temporary permissions.\n        // Grant Temporarly `ROOT_PERMISSION` to `pluginSetupProcessor`.\n        createdDao.grant(address(createdDao), address(pluginSetupProcessor), rootPermissionID);\n\n        // Grant Temporarly `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` to this `DAOFactory`.\n        createdDao.grant(\n            address(pluginSetupProcessor),\n            address(this),\n            applyInstallationPermissionID\n        );\n\n        // Install plugins on the newly created DAO.\n        for (uint256 i; i < _pluginSettings.length; ++i) {\n            // Prepare plugin.\n            (\n                address plugin,\n                IPluginSetup.PreparedSetupData memory preparedSetupData\n            ) = pluginSetupProcessor.prepareInstallation(\n                    address(createdDao),\n                    PluginSetupProcessor.PrepareInstallationParams(\n                        _pluginSettings[i].pluginSetupRef,\n                        _pluginSettings[i].data\n                    )\n                );\n\n            // Apply plugin.\n            pluginSetupProcessor.applyInstallation(\n                address(createdDao),\n                PluginSetupProcessor.ApplyInstallationParams(\n                    _pluginSettings[i].pluginSetupRef,\n                    plugin,\n                    preparedSetupData.permissions,\n                    hashHelpers(preparedSetupData.helpers)\n                )\n            );\n        }\n\n        // Set the rest of DAO's permissions.\n        _setDAOPermissions(createdDao);\n\n        // Revoke the temporarly granted permissions.\n        // Revoke Temporarly `ROOT_PERMISSION` from `pluginSetupProcessor`.\n        createdDao.revoke(address(createdDao), address(pluginSetupProcessor), rootPermissionID);\n\n        // Revoke `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` from this `DAOFactory` .\n        createdDao.revoke(\n            address(pluginSetupProcessor),\n            address(this),\n            applyInstallationPermissionID\n        );\n\n        // Revoke Temporarly `ROOT_PERMISSION_ID` from `pluginSetupProcessor` that implecitly granted to this `DaoFactory`\n        // at the create dao step `address(this)` being the initial owner of the new created DAO.\n        createdDao.revoke(address(createdDao), address(this), rootPermissionID);\n    }\n\n    /// @notice Deploys a new DAO `ERC1967` proxy, and initialize it with this contract as the intial owner.\n    /// @param _daoSettings The trusted forwarder, name and metadata hash of the DAO it creates.\n    function _createDAO(DAOSettings calldata _daoSettings) internal returns (DAO dao) {\n        // create dao\n        dao = DAO(payable(createERC1967Proxy(daoBase, bytes(\"\"))));\n\n        // initialize the DAO and give the `ROOT_PERMISSION_ID` permission to this contract.\n        dao.initialize(\n            _daoSettings.metadata,\n            address(this),\n            _daoSettings.trustedForwarder,\n            _daoSettings.daoURI\n        );\n    }\n\n    /// @notice Sets the required permissions for the new DAO.\n    /// @param _dao The DAO instance just created.\n    function _setDAOPermissions(DAO _dao) internal {\n        // set permissionIds on the dao itself.\n        PermissionLib.SingleTargetPermission[]\n            memory items = new PermissionLib.SingleTargetPermission[](6);\n\n        // Grant DAO all the permissions required\n        items[0] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.ROOT_PERMISSION_ID()\n        );\n        items[1] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.UPGRADE_DAO_PERMISSION_ID()\n        );\n        items[2] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.SET_SIGNATURE_VALIDATOR_PERMISSION_ID()\n        );\n        items[3] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.SET_TRUSTED_FORWARDER_PERMISSION_ID()\n        );\n        items[4] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.SET_METADATA_PERMISSION_ID()\n        );\n        items[5] = PermissionLib.SingleTargetPermission(\n            PermissionLib.Operation.Grant,\n            address(_dao),\n            _dao.REGISTER_STANDARD_CALLBACK_PERMISSION_ID()\n        );\n\n        _dao.applySingleTargetPermissions(address(_dao), items);\n    }\n}\n"
    },
    "@aragon/osx/core/dao/DAO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport {PermissionManager} from \"../permission/PermissionManager.sol\";\nimport {CallbackHandler} from \"../utils/CallbackHandler.sol\";\nimport {hasBit, flipBit} from \"../utils/BitMap.sol\";\nimport {IEIP4824} from \"./IEIP4824.sol\";\nimport {IDAO} from \"./IDAO.sol\";\n\n/// @title DAO\n/// @author Aragon Association - 2021-2023\n/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.\n/// @dev Public API of the Aragon DAO framework.\ncontract DAO is\n    IEIP4824,\n    Initializable,\n    IERC1271,\n    ERC165StorageUpgradeable,\n    IDAO,\n    UUPSUpgradeable,\n    PermissionManager,\n    CallbackHandler\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /// @notice The ID of the permission required to call the `execute` function.\n    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256(\"EXECUTE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256(\"UPGRADE_DAO_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setMetadata` function.\n    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256(\"SET_METADATA_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.\n    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =\n        keccak256(\"SET_TRUSTED_FORWARDER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `setSignatureValidator` function.\n    bytes32 public constant SET_SIGNATURE_VALIDATOR_PERMISSION_ID =\n        keccak256(\"SET_SIGNATURE_VALIDATOR_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerStandardCallback` function.\n    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =\n        keccak256(\"REGISTER_STANDARD_CALLBACK_PERMISSION\");\n\n    /// @notice The internal constant storing the maximal action array length.\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    /// @notice The [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    IERC1271 public signatureValidator;\n\n    /// @notice The address of the trusted forwarder verifying meta transactions.\n    address private trustedForwarder;\n\n    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO uri.\n    string private _daoURI;\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if an action has insufficent gas left.\n    error InsufficientGas();\n\n    /// @notice Thrown if the deposit amount is zero.\n    error ZeroAmount();\n\n    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.\n    /// @param expected The expected native token amount.\n    /// @param actual The actual native token amount deposited.\n    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);\n\n    /// @notice Emitted when a new DAO uri is set.\n    /// @param daoURI The new uri.\n    event NewURI(string daoURI);\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the DAO by\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the trusted forwarder for meta transactions\n    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.\n    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.\n    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.\n    function initialize(\n        bytes calldata _metadata,\n        address _initialOwner,\n        address _trustedForwarder,\n        string calldata daoURI_\n    ) external initializer {\n        _registerInterface(type(IDAO).interfaceId);\n        _registerInterface(type(IERC1271).interfaceId);\n        _registerInterface(type(IEIP4824).interfaceId);\n        _registerTokenInterfaces();\n\n        _setMetadata(_metadata);\n        _setTrustedForwarder(_trustedForwarder);\n        _setDaoURI(daoURI_);\n        __PermissionManager_init(_initialOwner);\n    }\n\n    /// @inheritdoc PermissionManager\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal pure override returns (bool) {\n        return\n            _permissionId == EXECUTE_PERMISSION_ID ||\n            _permissionId == UPGRADE_DAO_PERMISSION_ID ||\n            _permissionId == SET_METADATA_PERMISSION_ID ||\n            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||\n            _permissionId == SET_SIGNATURE_VALIDATOR_PERMISSION_ID ||\n            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}\n\n    /// @inheritdoc IDAO\n    function setTrustedForwarder(\n        address _newTrustedForwarder\n    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {\n        _setTrustedForwarder(_newTrustedForwarder);\n    }\n\n    /// @inheritdoc IDAO\n    function getTrustedForwarder() external view virtual override returns (address) {\n        return trustedForwarder;\n    }\n\n    /// @inheritdoc IDAO\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view override returns (bool) {\n        return isGranted(_where, _who, _permissionId, _data);\n    }\n\n    /// @inheritdoc IDAO\n    function setMetadata(\n        bytes calldata _metadata\n    ) external override auth(SET_METADATA_PERMISSION_ID) {\n        _setMetadata(_metadata);\n    }\n\n    /// @inheritdoc IDAO\n    function execute(\n        bytes32 _callId,\n        Action[] calldata _actions,\n        uint256 _allowFailureMap\n    )\n        external\n        override\n        auth(EXECUTE_PERMISSION_ID)\n        returns (bytes[] memory execResults, uint256 failureMap)\n    {\n        if (_actions.length > MAX_ACTIONS) {\n            revert TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        uint256 gasBefore;\n        uint256 gasAfter;\n\n        for (uint256 i = 0; i < _actions.length; ) {\n            gasBefore = gasleft();\n\n            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(\n                _actions[i].data\n            );\n            gasAfter = gasleft();\n\n            // Check if failure is allowed\n            if (!hasBit(_allowFailureMap, uint8(i))) {\n                // Check if the call failed.\n                if (!success) {\n                    revert ActionFailed(i);\n                }\n            } else {\n                // Check if the call failed.\n                if (!success) {\n                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see https://eips.ethereum.org/EIPS/eip-150).\n                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit\n                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.\n                    if (gasAfter < gasBefore / 64) {\n                        revert InsufficientGas();\n                    }\n\n                    // Store that this action failed.\n                    failureMap = flipBit(failureMap, uint8(i));\n                }\n            }\n\n            execResults[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// @inheritdoc IDAO\n    function deposit(\n        address _token,\n        uint256 _amount,\n        string calldata _reference\n    ) external payable override {\n        if (_amount == 0) revert ZeroAmount();\n\n        if (_token == address(0)) {\n            if (msg.value != _amount)\n                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});\n        } else {\n            if (msg.value != 0)\n                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});\n\n            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        emit Deposited(msg.sender, _token, _amount, _reference);\n    }\n\n    /// @inheritdoc IDAO\n    function setSignatureValidator(\n        address _signatureValidator\n    ) external override auth(SET_SIGNATURE_VALIDATOR_PERMISSION_ID) {\n        signatureValidator = IERC1271(_signatureValidator);\n\n        emit SignatureValidatorSet({signatureValidator: _signatureValidator});\n    }\n\n    /// @inheritdoc IDAO\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view override(IDAO, IERC1271) returns (bytes4) {\n        if (address(signatureValidator) == address(0)) {\n            // Return the invalid magic number\n            return bytes4(0);\n        }\n        // Forward the call to the set signature validator contract\n        return signatureValidator.isValidSignature(_hash, _signature);\n    }\n\n    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.\n    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by EIP-2929.\n    /// Gas cost increases in future hard forks might break this function. As an alternative, EIP-2930-type transactions using access lists can be employed.\n    receive() external payable {\n        emit NativeTokenDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.\n    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)\n    /// @return The magic number registered for the function selector triggering the fallback.\n    fallback(bytes calldata _input) external returns (bytes memory) {\n        bytes4 magicNumber = _handleCallback(msg.sig, _input);\n        return abi.encode(magicNumber);\n    }\n\n    /// @notice Emits the MetadataSet event if new metadata is set.\n    /// @param _metadata Hash of the IPFS metadata object.\n    function _setMetadata(bytes calldata _metadata) internal {\n        emit MetadataSet(_metadata);\n    }\n\n    /// @notice Sets the trusted forwarder on the DAO and emits the associated event.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function _setTrustedForwarder(address _trustedForwarder) internal {\n        trustedForwarder = _trustedForwarder;\n\n        emit TrustedForwarderSet(_trustedForwarder);\n    }\n\n    /// @notice Registers the ERC721/ERC1155 interfaces and callbacks.\n    function _registerTokenInterfaces() private {\n        _registerInterface(type(IERC721ReceiverUpgradeable).interfaceId);\n        _registerInterface(type(IERC1155ReceiverUpgradeable).interfaceId);\n\n        _registerCallback(\n            IERC721ReceiverUpgradeable.onERC721Received.selector,\n            IERC721ReceiverUpgradeable.onERC721Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector,\n            IERC1155ReceiverUpgradeable.onERC1155Received.selector\n        );\n        _registerCallback(\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector,\n            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector\n        );\n    }\n\n    /// @inheritdoc IDAO\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {\n        _registerInterface(_interfaceId);\n        _registerCallback(_callbackSelector, _magicNumber);\n        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);\n    }\n\n    /// @inheritdoc IEIP4824\n    function daoURI() external view returns (string memory) {\n        return _daoURI;\n    }\n\n    /// @notice Updates the set DAO uri to a new value.\n    /// @param newDaoURI The new DAO uri to be set.\n    function setDaoURI(string calldata newDaoURI) external auth(SET_METADATA_PERMISSION_ID) {\n        _setDaoURI(newDaoURI);\n    }\n\n    /// @notice Sets the new DAO uri and emits the associated event.\n    /// @param daoURI_ The new DAO uri.\n    function _setDaoURI(string calldata daoURI_) internal {\n        _daoURI = daoURI_;\n\n        emit NewURI(daoURI_);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n"
    },
    "@aragon/osx/core/permission/PermissionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./IPermissionCondition.sol\";\nimport \"./PermissionLib.sol\";\n\n/// @title PermissionManager\n/// @author Aragon Association - 2021-2023\n/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.\nabstract contract PermissionManager is Initializable {\n    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\"ROOT_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\n    address internal constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\n    address internal constant UNSET_FLAG = address(0);\n\n    /// @notice A special address encoding if a permission is allowed.\n    address internal constant ALLOW_FLAG = address(2);\n\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).\n    mapping(bytes32 => address) internal permissionsHashed;\n\n    /// @notice Thrown if a call is unauthorized.\n    /// @param where The context in which the authorization reverted.\n    /// @param who The address (EOA or contract) missing the permission.\n    /// @param permissionId The permission identifier.\n    error Unauthorized(address where, address who, bytes32 permissionId);\n\n    /// @notice Thrown if a permission has been already granted with a different condition.\n    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.\n    /// @param where The address of the target contract to grant `_who` permission to.\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\n    /// @param permissionId The permission identifier.\n    /// @param currentCondition The current condition set for permissionId.\n    /// @param newCondition The new condition it tries to set for permissionId.\n    error PermissionAlreadyGrantedForDifferentCondition(\n        address where,\n        address who,\n        bytes32 permissionId,\n        address currentCondition,\n        address newCondition\n    );\n\n    /// @notice Thrown for permission grants where `who` or `where` is `ANY_ADDR`, but no condition is present.\n    error ConditionNotPresentForAnyAddress();\n\n    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.\n    error PermissionsForAnyAddressDisallowed();\n\n    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.\n    error AnyAddressDisallowedForWhoAndWhere();\n\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is granted.\n    /// @param where The address of the target contract for which `_who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `PermissionCondition` to be used.\n    event Granted(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who,\n        IPermissionCondition condition\n    );\n\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is revoked.\n    /// @param where The address of the target contract for which `_who` loses permission.\n    /// @param who The address (EOA or contract) losing the permission.\n    event Revoked(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who\n    );\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(_permissionId);\n        _;\n    }\n\n    /// @notice Initialization method to set the initial owner of the permission manager.\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {\n        _initializePermissionManager(_initialOwner);\n    }\n\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grant(_where, _who, _permissionId);\n    }\n\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grantWithCondition(_where, _who, _permissionId, _condition);\n    }\n\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` loses permission.\n    /// @param _who The address (EOA or contract) losing the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n\n    /// @notice Applies an array of permission operations on a single target contracts `_where`.\n    /// @param _where The address of the single target contract.\n    /// @param items The array of single-targeted permission operations to apply.\n    function applySingleTargetPermissions(\n        address _where,\n        PermissionLib.SingleTargetPermission[] calldata items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < items.length; ) {\n            PermissionLib.SingleTargetPermission memory item = items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(_where, item.who, item.permissionId);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.\n    /// @param _items The array of multi-targeted permission operations to apply.\n    function applyMultiTargetPermissions(\n        PermissionLib.MultiTargetPermission[] calldata _items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < _items.length; ) {\n            PermissionLib.MultiTargetPermission memory item = _items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\n                _grantWithCondition(\n                    item.where,\n                    item.who,\n                    item.permissionId,\n                    IPermissionCondition(item.condition)\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) for which the permission is checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) public view virtual returns (bool) {\n        return\n            _isGranted(_where, _who, _permissionId, _data) || // check if `_who` has permission for `_permissionId` on `_where`\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for `_permissionId` on `_where`\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if `_who` has permission for `_permissionI` on any contract\n    }\n\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function _initializePermissionManager(address _initialOwner) internal {\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\n    }\n\n    /// @notice This method is used in the public `grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {\n        _grantWithCondition(_where, _who, _permissionId, IPermissionCondition(ALLOW_FLAG));\n    }\n\n    /// @notice This method is used in the internal `_grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function _grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) internal virtual {\n        if (_where == ANY_ADDR && _who == ANY_ADDR) {\n            revert AnyAddressDisallowedForWhoAndWhere();\n        }\n\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\n            bool isRestricted = isPermissionRestrictedForAnyAddr(_permissionId);\n            if (_permissionId == ROOT_PERMISSION_ID || isRestricted) {\n                revert PermissionsForAnyAddressDisallowed();\n            }\n\n            if (address(_condition) == ALLOW_FLAG) {\n                revert ConditionNotPresentForAnyAddress();\n            }\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        address currentCondition = permissionsHashed[permHash];\n        address newCondition = address(_condition);\n\n        // Means permHash is not currently set.\n        if (currentCondition == UNSET_FLAG) {\n            permissionsHashed[permHash] = newCondition;\n\n            emit Granted(_permissionId, msg.sender, _where, _who, _condition);\n        } else if (currentCondition != newCondition) {\n            // Revert if `permHash` is already granted, but uses a different condition.\n            // If we don't revert, we either should:\n            //   - allow overriding the condition on the same permission\n            //     which could be confusing whoever granted the same permission first\n            //   - or do nothing and succeed silently which could be confusing for the caller.\n            revert PermissionAlreadyGrantedForDifferentCondition({\n                where: _where,\n                who: _who,\n                permissionId: _permissionId,\n                currentCondition: currentCondition,\n                newCondition: newCondition\n            });\n        }\n    }\n\n    /// @notice This method is used in the public `revoke` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that might have been granted in parallel.\n    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\n            permissionsHashed[permHash] = UNSET_FLAG;\n\n            emit Revoked(_permissionId, msg.sender, _where, _who);\n        }\n    }\n\n    /// @notice Checks if a caller is granted permissions on a target contract via a permission identifier and redirects the approval to a `PermissionCondition` if this was specified in the setup.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the contract via the specified permissionId identifier.\n    function _isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) internal view virtual returns (bool) {\n        address accessFlagOrCondition = permissionsHashed[\n            permissionHash(_where, _who, _permissionId)\n        ];\n\n        if (accessFlagOrCondition == UNSET_FLAG) return false;\n        if (accessFlagOrCondition == ALLOW_FLAG) return true;\n\n        // Since it's not a flag, assume it's a PermissionCondition and try-catch to skip failures\n        try\n            IPermissionCondition(accessFlagOrCondition).isGranted(\n                _where,\n                _who,\n                _permissionId,\n                _data\n            )\n        returns (bool allowed) {\n            if (allowed) return true;\n        } catch {}\n\n        return false;\n    }\n\n    /// @notice A private function to be used to check permissions on the permission manager contract (`address(this)`) itself.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    function _auth(bytes32 _permissionId) internal view virtual {\n        if (!isGranted(address(this), msg.sender, _permissionId, msg.data)) {\n            revert Unauthorized({\n                where: address(this),\n                who: msg.sender,\n                permissionId: _permissionId\n            });\n        }\n    }\n\n    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word \"PERMISSION\", the contract address, the address owning the permission, and the permission identifier.\n    /// @param _where The address of the target contract for which `_who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @return The permission hash.\n    function permissionHash(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal pure virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"PERMISSION\", _who, _where, _permissionId));\n    }\n\n    /// @notice Decides if the granting permissionId is restricted when `_who = ANY_ADDR` or `_where = ANY_ADDR`.\n    /// @param _permissionId The permission identifier.\n    /// @return Whether or not the permission is restricted.\n    /// @dev By default, every permission is unrestricted and it is the derived contract's responsibility to override it. Note, that the `ROOT_PERMISSION_ID` is included not required to be set it again.\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal view virtual returns (bool) {\n        (_permissionId); // silence the warning.\n        return false;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/permission/IPermissionCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title IPermissionCondition\n/// @author Aragon Association - 2021-2023\n/// @notice This interface can be implemented to support more customary permissions depending on on- or off-chain state, e.g., by querying token ownershop or a secondary condition, respectively.\ninterface IPermissionCondition {\n    /// @notice This method is used to check if a call is permitted.\n    /// @param _where The address of the target contract.\n    /// @param _who The address (EOA or contract) for which the permission are checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data Optional data passed to the `PermissionCondition` implementation.\n    /// @return allowed Returns true if the call is permitted.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes calldata _data\n    ) external view returns (bool allowed);\n}\n"
    },
    "@aragon/osx/core/permission/PermissionLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title PermissionLib\n/// @author Aragon Association - 2021-2023\n/// @notice A library containing objects for permission processing.\nlibrary PermissionLib {\n    /// @notice A constant expressing that no condition is applied to a permission.\n    address public constant NO_CONDITION = address(0);\n\n    /// @notice The types of permission operations available in the `PermissionManager`.\n    /// @param Grant The grant operation setting a permission without a condition.\n    /// @param Revoke The revoke operation removing a permission (that was granted with or without a condition).\n    /// @param GrantWithCondition The grant operation setting a permission with a condition.\n    enum Operation {\n        Grant,\n        Revoke,\n        GrantWithCondition\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on a single target contract without a condition.\n    /// @param operation The permission operation type.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param permissionId The permission identifier.\n    struct SingleTargetPermission {\n        Operation operation;\n        address who;\n        bytes32 permissionId;\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on multiple target contracts, optionally, with a conditon.\n    /// @param operation The permission operation type.\n    /// @param where The address of the target contract for which `who` recieves permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @param permissionId The permission identifier.\n    struct MultiTargetPermission {\n        Operation operation;\n        address where;\n        address who;\n        address condition;\n        bytes32 permissionId;\n    }\n}\n"
    },
    "@aragon/osx/core/utils/CallbackHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title CallbackHandler\n/// @author Aragon Association - 2022-2023\n/// @notice This contract handles callbacks by registering a magic number together with the callback function's selector. It provides the `_handleCallback` function that inherting have to call inside their `fallback()` function  (`_handleCallback(msg.callbackSelector, msg.data)`).  This allows to adaptively register ERC standards (e.g., [ERC-721](https://eips.ethereum.org/EIPS/eip-721), [ERC-1115](https://eips.ethereum.org/EIPS/eip-1155), or future versions of [ERC-165](https://eips.ethereum.org/EIPS/eip-165)) and returning the required magic numbers for the associated callback functions for the inheriting contract so that it doesn't need to be upgraded.\n/// @dev This callback handling functionality is intented to be used by executor contracts (i.e., `DAO.sol`).\nabstract contract CallbackHandler {\n    /// @notice A mapping between callback function selectors and magic return numbers.\n    mapping(bytes4 => bytes4) internal callbackMagicNumbers;\n\n    /// @notice The magic number refering to unregistered callbacks.\n    bytes4 internal constant UNREGISTERED_CALLBACK = bytes4(0);\n\n    /// @notice Thrown if the callback function is not registered.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    error UnkownCallback(bytes4 callbackSelector, bytes4 magicNumber);\n\n    /// @notice Emitted when `_handleCallback` is called.\n    /// @param sender Who called the callback.\n    /// @param sig The function signature.\n    /// @param data The calldata for the function signature.\n    event CallbackReceived(address sender, bytes4 indexed sig, bytes data);\n\n    /// @notice Handles callbacks to adaptively support ERC standards.\n    /// @dev This function is supposed to be called via `_handleCallback(msg.sig, msg.data)` in the `fallback()` function of the inheriting contract.\n    /// @param _callbackSelector The function selector of the callback function.\n    /// @return The magic number registered for the function selector triggering the fallback.\n    function _handleCallback(\n        bytes4 _callbackSelector,\n        bytes memory _data\n    ) internal virtual returns (bytes4) {\n        bytes4 magicNumber = callbackMagicNumbers[_callbackSelector];\n        if (magicNumber == UNREGISTERED_CALLBACK) {\n            revert UnkownCallback({callbackSelector: _callbackSelector, magicNumber: magicNumber});\n        }\n\n        emit CallbackReceived({sender: msg.sender, sig: _callbackSelector, data: _data});\n\n        return magicNumber;\n    }\n\n    /// @notice Registers a magic number for a callback function selector.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the callback function selector.\n    function _registerCallback(bytes4 _callbackSelector, bytes4 _magicNumber) internal virtual {\n        callbackMagicNumbers[_callbackSelector] = _magicNumber;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/utils/BitMap.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @param bitmap The `uint256` representation of bits.\n/// @param index The index number to check whether 1 or 0 is set.\n/// @return Returns `true` whether the bit is set at `index` on `bitmap`.\nfunction hasBit(uint256 bitmap, uint8 index) pure returns (bool) {\n    uint256 bitValue = bitmap & (1 << index);\n    return bitValue > 0;\n}\n\n/// @param bitmap The `uint256` representation of bits.\n/// @param index The index number to set the bit.\n/// @return Returns a new number on which the bit is set at `index`.\nfunction flipBit(uint256 bitmap, uint8 index) pure returns (uint256) {\n    return bitmap ^ (1 << index);\n}\n"
    },
    "@aragon/osx/core/dao/IEIP4824.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title EIP-4824 Common Interfaces for DAOs\n/// @dev See https://eips.ethereum.org/EIPS/eip-4824\n/// @author Aragon Association - 2021-2023\ninterface IEIP4824 {\n    /// @notice A distinct Uniform Resource Identifier (URI) pointing to a JSON object following the \"EIP-4824 DAO JSON-LD Schema\". This JSON file splits into four URIs: membersURI, proposalsURI, activityLogURI, and governanceURI. The membersURI should point to a JSON file that conforms to the \"EIP-4824 Members JSON-LD Schema\". The proposalsURI should point to a JSON file that conforms to the \"EIP-4824 Proposals JSON-LD Schema\". The activityLogURI should point to a JSON file that conforms to the \"EIP-4824 Activity Log JSON-LD Schema\". The governanceURI should point to a flatfile, normatively a .md file. Each of the JSON files named above can be statically-hosted or dynamically-generated.\n    function daoURI() external view returns (string memory _daoURI);\n}\n"
    },
    "@aragon/osx/core/dao/IDAO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title IDAO\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\ninterface IDAO {\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire excution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Setter for the [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    /// @param _signatureValidator The address of the signature validator.\n    function setSignatureValidator(address _signatureValidator) external;\n\n    /// @notice Emitted when the signature validator address is updated.\n    /// @param signatureValidator The address of the signature validator.\n    event SignatureValidatorSet(address signatureValidator);\n\n    /// @notice Checks whether a signature is valid for the provided hash by forwarding the call to the set [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n}\n"
    },
    "@aragon/osx/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/// @notice Free function to create a [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract based on the passed base contract address.\n/// @param _logic The base contract address.\n/// @param _data The constructor arguments for this contract.\n/// @return The address of the proxy contract created.\n/// @dev Initializes the upgradeable proxy with an initial implementation specified by _logic. If _data is non-empty, its used as data in a delegate call to _logic. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor (see [OpenZepplin ERC1967Proxy-constructor](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-)).\nfunction createERC1967Proxy(address _logic, bytes memory _data) returns (address) {\n    return address(new ERC1967Proxy(_logic, _data));\n}\n"
    },
    "@aragon/osx/framework/plugin/repo/PluginRepo.sol": {
      "content": "// SPDX-License-Identifier:    AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport {PermissionManager} from \"../../../core/permission/PermissionManager.sol\";\nimport {PluginSetup} from \"../setup/PluginSetup.sol\";\nimport {IPluginSetup} from \"../setup/PluginSetup.sol\";\nimport {IPluginRepo} from \"./IPluginRepo.sol\";\n\n/// @title PluginRepo\n/// @author Aragon Association - 2020 - 2023\n/// @notice The plugin repository contract required for managing and publishing different plugin versions within the Aragon DAO framework.\ncontract PluginRepo is\n    Initializable,\n    ERC165Upgradeable,\n    IPluginRepo,\n    UUPSUpgradeable,\n    PermissionManager\n{\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice The struct describing the tag of a version obtained by a release and build number as `RELEASE.BUILD`.\n    /// @param release The release number.\n    /// @param build The build number\n    /// @dev Releases can include a storage layout or the addition of new functions. Builds include logic changes or updates of the UI.\n    struct Tag {\n        uint8 release;\n        uint16 build;\n    }\n\n    /// @notice The struct describing a plugin version (release and build).\n    /// @param tag The version tag.\n    /// @param pluginSetup The setup contract associated with this version.\n    /// @param buildMetadata The build metadata URI.\n    struct Version {\n        Tag tag;\n        address pluginSetup;\n        bytes buildMetadata;\n    }\n\n    /// @notice The ID of the permission required to call the `createVersion` function.\n    bytes32 public constant MAINTAINER_PERMISSION_ID = keccak256(\"MAINTAINER_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `createVersion` function.\n    bytes32 public constant UPGRADE_REPO_PERMISSION_ID = keccak256(\"UPGRADE_REPO_PERMISSION\");\n\n    /// @notice The mapping between release and build numbers.\n    mapping(uint8 => uint16) internal buildsPerRelease;\n\n    /// @notice The mapping between the version hash and the corresponding version information.\n    mapping(bytes32 => Version) internal versions;\n\n    /// @notice The mapping between the plugin setup address and its corresponding version hash.\n    mapping(address => bytes32) internal latestTagHashForPluginSetup;\n\n    /// @notice The ID of the latest release.\n    /// @dev The maximum release number is 255.\n    uint8 public latestRelease;\n\n    /// @notice Thrown if a version does not exist.\n    /// @param versionHash The tag hash.\n    error VersionHashDoesNotExist(bytes32 versionHash);\n\n    /// @notice Thrown if a plugin setup contract does not inherit from `PluginSetup`.\n    error InvalidPluginSetupInterface();\n\n    /// @notice Thrown if a release number is zero.\n    error ReleaseZeroNotAllowed();\n\n    /// @notice Thrown if a release number is incremented by more than one.\n    /// @param latestRelease The latest release number.\n    /// @param newRelease The new release number.\n    error InvalidReleaseIncrement(uint8 latestRelease, uint8 newRelease);\n\n    /// @notice Thrown if the same plugin setup contract exists already in a previous releases.\n    /// @param release The release number of the already existing plugin setup.\n    /// @param build The build number of the already existing plugin setup.\n    /// @param pluginSetup The plugin setup contract address.\n    error PluginSetupAlreadyInPreviousRelease(uint8 release, uint16 build, address pluginSetup);\n\n    /// @notice Thrown if the metadata URI is empty.\n    error EmptyReleaseMetadata();\n\n    /// @notice Thrown if release does not exist.\n    error ReleaseDoesNotExist();\n\n    /// @notice Thrown if the same plugin setup exists in previous releases.\n    /// @param release The release number.\n    /// @param build The build number.\n    /// @param pluginSetup The address of the plugin setup contract.\n    /// @param buildMetadata The build metadata URI.\n    event VersionCreated(\n        uint8 release,\n        uint16 build,\n        address indexed pluginSetup,\n        bytes buildMetadata\n    );\n\n    /// @notice Thrown when a release's metadata was updated.\n    /// @param release The release number.\n    /// @param releaseMetadata The release metadata URI.\n    event ReleaseMetadataUpdated(uint8 release, bytes releaseMetadata);\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract by\n    /// - initializing the permission manager\n    /// - granting the `MAINTAINER_PERMISSION_ID` permission to the initial owner.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    function initialize(address initialOwner) external initializer {\n        __PermissionManager_init(initialOwner);\n\n        _grant(address(this), initialOwner, MAINTAINER_PERMISSION_ID);\n        _grant(address(this), initialOwner, UPGRADE_REPO_PERMISSION_ID);\n    }\n\n    /// @inheritdoc IPluginRepo\n    function createVersion(\n        uint8 _release,\n        address _pluginSetup,\n        bytes calldata _buildMetadata,\n        bytes calldata _releaseMetadata\n    ) external auth(MAINTAINER_PERMISSION_ID) {\n        if (!_pluginSetup.supportsInterface(type(IPluginSetup).interfaceId)) {\n            revert InvalidPluginSetupInterface();\n        }\n\n        if (_release == 0) {\n            revert ReleaseZeroNotAllowed();\n        }\n\n        // Check that the release number is not incremented by more than one\n        if (_release - latestRelease > 1) {\n            revert InvalidReleaseIncrement({latestRelease: latestRelease, newRelease: _release});\n        }\n\n        if (_release > latestRelease) {\n            latestRelease = _release;\n\n            if (_releaseMetadata.length == 0) {\n                revert EmptyReleaseMetadata();\n            }\n        }\n\n        // Make sure the same plugin setup wasn't used in previous releases.\n        Version storage version = versions[latestTagHashForPluginSetup[_pluginSetup]];\n        if (version.tag.release != 0 && version.tag.release != _release) {\n            revert PluginSetupAlreadyInPreviousRelease(\n                version.tag.release,\n                version.tag.build,\n                _pluginSetup\n            );\n        }\n\n        uint16 build = ++buildsPerRelease[_release];\n\n        Tag memory tag = Tag(_release, build);\n        bytes32 _tagHash = tagHash(tag);\n\n        versions[_tagHash] = Version(tag, _pluginSetup, _buildMetadata);\n\n        latestTagHashForPluginSetup[_pluginSetup] = _tagHash;\n\n        emit VersionCreated({\n            release: _release,\n            build: build,\n            pluginSetup: _pluginSetup,\n            buildMetadata: _buildMetadata\n        });\n\n        if (_releaseMetadata.length > 0) {\n            emit ReleaseMetadataUpdated(_release, _releaseMetadata);\n        }\n    }\n\n    /// @inheritdoc IPluginRepo\n    function updateReleaseMetadata(\n        uint8 _release,\n        bytes calldata _releaseMetadata\n    ) external auth(MAINTAINER_PERMISSION_ID) {\n        if (_release == 0) {\n            revert ReleaseZeroNotAllowed();\n        }\n\n        if (_release > latestRelease) {\n            revert ReleaseDoesNotExist();\n        }\n\n        if (_releaseMetadata.length == 0) {\n            revert EmptyReleaseMetadata();\n        }\n\n        emit ReleaseMetadataUpdated(_release, _releaseMetadata);\n    }\n\n    /// @notice Returns the latest version for a given release number.\n    /// @param _release The release number.\n    /// @return The latest version of this release.\n    function getLatestVersion(uint8 _release) public view returns (Version memory) {\n        uint16 latestBuild = uint16(buildsPerRelease[_release]);\n        return getVersion(tagHash(Tag(_release, latestBuild)));\n    }\n\n    /// @notice Returns the latest version for a given plugin setup.\n    /// @param _pluginSetup The plugin setup address\n    /// @return The latest version associated with the plugin Setup.\n    function getLatestVersion(address _pluginSetup) public view returns (Version memory) {\n        return getVersion(latestTagHashForPluginSetup[_pluginSetup]);\n    }\n\n    /// @notice Returns the version associated with a tag.\n    /// @param _tag The version tag.\n    /// @return The version associated with the tag.\n    function getVersion(Tag calldata _tag) public view returns (Version memory) {\n        return getVersion(tagHash(_tag));\n    }\n\n    /// @notice Returns the version for a tag hash.\n    /// @param _tagHash The tag hash.\n    /// @return The version associated with a tag hash.\n    function getVersion(bytes32 _tagHash) public view returns (Version memory) {\n        Version storage version = versions[_tagHash];\n\n        if (version.tag.release == 0) {\n            revert VersionHashDoesNotExist(_tagHash);\n        }\n\n        return version;\n    }\n\n    /// @notice Gets the total number of builds for a given release number.\n    /// @param _release The release number.\n    /// @return The number of builds of this release.\n    function buildCount(uint8 _release) public view returns (uint256) {\n        return buildsPerRelease[_release];\n    }\n\n    /// @notice The hash of the version tag obtained from the packed, bytes-encoded release and build number.\n    /// @param _tag The version tag.\n    /// @return The version tag hash.\n    function tagHash(Tag memory _tag) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_tag.release, _tag.build));\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_REPO_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_REPO_PERMISSION_ID) {}\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPluginRepo).interfaceId ||\n            _interfaceId == type(UUPSUpgradeable).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/PluginSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {createERC1967Proxy as createERC1967} from \"../../../utils/Proxy.sol\";\nimport {IPluginSetup} from \"./IPluginSetup.sol\";\n\n/// @title PluginSetup\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract contract that developers have to inherit from to write the setup of a plugin.\nabstract contract PluginSetup is ERC165, IPluginSetup {\n    /// @inheritdoc IPluginSetup\n    function prepareUpdate(\n        address _dao,\n        uint16 _currentBuild,\n        SetupPayload calldata _payload\n    )\n        external\n        virtual\n        override\n        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)\n    {}\n\n    /// @notice A convenience function to create an [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract pointing to an implementation and being associated to a DAO.\n    /// @param _implementation The address of the implementation contract to which the proxy is pointing to.\n    /// @param _data The data to initialize the storage of the proxy contract.\n    /// @return The address of the created proxy contract.\n    function createERC1967Proxy(\n        address _implementation,\n        bytes memory _data\n    ) internal returns (address) {\n        return createERC1967(_implementation, _data);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPluginSetup).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/IPluginSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\n\n/// @title IPluginSetup\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for a plugin setup contract to be consumed by the `PluginSetupProcessor` for plugin installations, updates, and uninstallations.\ninterface IPluginSetup {\n    /// @notice The data associated with a prepared setup.\n    /// @param helpers The address array of helpers (contracts or EOAs) associated with this plugin version after the installation or update.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the installing or updating DAO.\n    struct PreparedSetupData {\n        address[] helpers;\n        PermissionLib.MultiTargetPermission[] permissions;\n    }\n\n    /// @notice The payload for plugin updates and uninstallations containing the existing contracts as well as optional data to be consumed by the plugin setup.\n    /// @param plugin The address of the `Plugin`.\n    /// @param currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\n    /// @param data The bytes-encoded data containing the input parameters for the preparation of update/uninstall as specified in the corresponding ABI on the version's metadata.\n    struct SetupPayload {\n        address plugin;\n        address[] currentHelpers;\n        bytes data;\n    }\n\n    /// @notice Prepares the installation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\n    /// @return plugin The address of the `Plugin` contract being prepared for installation.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareInstallation(\n        address _dao,\n        bytes calldata _data\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the update of a plugin.\n    /// @param _dao The address of the updating DAO.\n    /// @param _currentBuild The build number of the plugin to update from.\n    /// @param _payload The relevant data necessary for the `prepareUpdate`. see above.\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied in the `PluginSetupProcessor`.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareUpdate(\n        address _dao,\n        uint16 _currentBuild,\n        SetupPayload calldata _payload\n    ) external returns (bytes memory initData, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the uninstallation of a plugin.\n    /// @param _dao The address of the uninstalling DAO.\n    /// @param _payload The relevant data necessary for the `prepareUninstallation`. see above.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the uninstalling DAO.\n    function prepareUninstallation(\n        address _dao,\n        SetupPayload calldata _payload\n    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions);\n\n    /// @notice Returns the plugin implementation address.\n    /// @return The address of the plugin implementation contract.\n    /// @dev The implementation can be instantiated via the `new` keyword, cloned via the minimal clones pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)), or proxied via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    function implementation() external view returns (address);\n}\n"
    },
    "@aragon/osx/framework/plugin/repo/IPluginRepo.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title IPluginRepo\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for a plugin repository.\ninterface IPluginRepo {\n    /// @notice Update the metadata for release with content `@fromHex(_releaseMetadata)`.\n    /// @param _release The release number.\n    /// @param _releaseMetadata The release metadata URI.\n    function updateReleaseMetadata(uint8 _release, bytes calldata _releaseMetadata) external;\n\n    /// @notice Creates a new plugin version as the latest build for an existing release number or the first build for a new release number for the provided `PluginSetup` contract address and metadata.\n    /// @param _release The release number.\n    /// @param _pluginSetupAddress The address of the plugin setup contract.\n    /// @param _buildMetadata The build metadata URI.\n    /// @param _releaseMetadata The release metadata URI.\n    function createVersion(\n        uint8 _release,\n        address _pluginSetupAddress,\n        bytes calldata _buildMetadata,\n        bytes calldata _releaseMetadata\n    ) external;\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/PluginSetupProcessor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {DAO, IDAO} from \"../../../core/dao/DAO.sol\";\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {PluginUUPSUpgradeable} from \"../../../core/plugin/PluginUUPSUpgradeable.sol\";\nimport {IPlugin} from \"../../../core/plugin/IPlugin.sol\";\n\nimport {PluginRepoRegistry} from \"../repo/PluginRepoRegistry.sol\";\nimport {PluginRepo} from \"../repo/PluginRepo.sol\";\n\nimport {IPluginSetup} from \"./IPluginSetup.sol\";\nimport {PluginSetup} from \"./PluginSetup.sol\";\nimport {PluginSetupRef, hashHelpers, hashPermissions, _getPreparedSetupId, _getAppliedSetupId, _getPluginInstallationId, PreparationType} from \"./PluginSetupProcessorHelpers.sol\";\n\n/// @title PluginSetupProcessor\n/// @author Aragon Association - 2022-2023\n/// @notice This contract processes the preparation and application of plugin setups (installation, update, uninstallation) on behalf of a requesting DAO.\n/// @dev This contract is temporarily granted the `ROOT_PERMISSION_ID` permission on the applying DAO and therefore is highly security critical.\ncontract PluginSetupProcessor {\n    using ERC165Checker for address;\n\n    /// @notice The ID of the permission required to call the `applyInstallation` function.\n    bytes32 public constant APPLY_INSTALLATION_PERMISSION_ID =\n        keccak256(\"APPLY_INSTALLATION_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `applyUpdate` function.\n    bytes32 public constant APPLY_UPDATE_PERMISSION_ID = keccak256(\"APPLY_UPDATE_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `applyUninstallation` function.\n    bytes32 public constant APPLY_UNINSTALLATION_PERMISSION_ID =\n        keccak256(\"APPLY_UNINSTALLATION_PERMISSION\");\n\n    /// @notice The hash obtained from the bytes-encoded empty array to be used for UI updates being required to submit an empty permission array.\n    /// @dev The hash is computed via `keccak256(abi.encode([]))`.\n    bytes32 private constant EMPTY_ARRAY_HASH =\n        0x569e75fc77c1a856f6daaf9e69d8a9566ca34aa47f9133711ce065a571af0cfd;\n\n    /// @notice The hash obtained from the bytes-encoded zero value.\n    /// @dev The hash is computed via `keccak256(abi.encode(0))`.\n    bytes32 private constant ZERO_BYTES_HASH =\n        0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\n\n    /// @notice A struct containing information related to plugin setups that have been applied.\n    /// @param blockNumber The block number at which the `applyInstallation`, `applyUpdate` or `applyUninstallation` was executed.\n    /// @param currentAppliedSetupId The current setup id that plugin holds. Needed to confirm that `prepareUpdate` or `prepareUninstallation` happens for the plugin's current/valid dependencies.\n    /// @param preparedSetupIdToBlockNumber The mapping between prepared setup IDs and block numbers at which `prepareInstallation`, `prepareUpdate` or `prepareUninstallation` was executed.\n    struct PluginState {\n        uint256 blockNumber;\n        bytes32 currentAppliedSetupId;\n        mapping(bytes32 => uint256) preparedSetupIdToBlockNumber;\n    }\n\n    /// @notice A mapping between the plugin installation ID (obtained from the DAO and plugin address) and the plugin state information.\n    /// @dev This variable is public on purpose to allow future versions to access and migrate the storage.\n    mapping(bytes32 => PluginState) public states;\n\n    /// @notice The struct containing the parameters for the `prepareInstallation` function.\n    /// @param pluginSetupRef The reference to the plugin setup to be used for the installation.\n    /// @param data The bytes-encoded data containing the input parameters for the installation preparation as specified in the corresponding ABI on the version's metadata.\n    struct PrepareInstallationParams {\n        PluginSetupRef pluginSetupRef;\n        bytes data;\n    }\n\n    /// @notice The struct containing the parameters for the `applyInstallation` function.\n    /// @param pluginSetupRef The reference to the plugin setup used for the installation.\n    /// @param plugin The address of the plugin contract to be installed.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the DAO.\n    /// @param helpersHash The hash of helpers that were deployed in `prepareInstallation`. This helps to derive the setup ID.\n    struct ApplyInstallationParams {\n        PluginSetupRef pluginSetupRef;\n        address plugin;\n        PermissionLib.MultiTargetPermission[] permissions;\n        bytes32 helpersHash;\n    }\n\n    /// @notice The struct containing the parameters for the `prepareUpdate` function.\n    /// @param currentVersionTag The tag of the current plugin version to update from.\n    /// @param newVersionTag The tag of the new plugin version to update to.\n    /// @param pluginSetupRepo The plugin setup repository address on which the plugin exists.\n    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.\n    ///  This includes the bytes-encoded data containing the input parameters for the update preparation as specified in the corresponding ABI on the version's metadata.\n    struct PrepareUpdateParams {\n        PluginRepo.Tag currentVersionTag;\n        PluginRepo.Tag newVersionTag;\n        PluginRepo pluginSetupRepo;\n        IPluginSetup.SetupPayload setupPayload;\n    }\n\n    /// @notice The struct containing the parameters for the `applyUpdate` function.\n    /// @param plugin The address of the plugin contract to be updated.\n    /// @param pluginSetupRef The reference to the plugin setup used for the update.\n    /// @param initData The encoded data (function selector and arguments) to be provided to `upgradeToAndCall`.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the DAO.\n    /// @param helpersHash The hash of helpers that were deployed in `prepareUpdate`. This helps to derive the setup ID.\n    struct ApplyUpdateParams {\n        address plugin;\n        PluginSetupRef pluginSetupRef;\n        bytes initData;\n        PermissionLib.MultiTargetPermission[] permissions;\n        bytes32 helpersHash;\n    }\n\n    /// @notice The struct containing the parameters for the `prepareUninstallation` function.\n    /// @param pluginSetupRef The reference to the plugin setup to be used for the uninstallation.\n    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.\n    ///  This includes the bytes-encoded data containing the input parameters for the uninstallation preparation as specified in the corresponding ABI on the version's metadata.\n    struct PrepareUninstallationParams {\n        PluginSetupRef pluginSetupRef;\n        IPluginSetup.SetupPayload setupPayload;\n    }\n\n    /// @notice The struct containing the parameters for the `applyInstallation` function.\n    /// @param plugin The address of the plugin contract to be uninstalled.\n    /// @param pluginSetupRef The reference to the plugin setup used for the uninstallation.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcess.\n    struct ApplyUninstallationParams {\n        address plugin;\n        PluginSetupRef pluginSetupRef;\n        PermissionLib.MultiTargetPermission[] permissions;\n    }\n\n    /// @notice The plugin repo registry listing the `PluginRepo` contracts versioning the `PluginSetup` contracts.\n    PluginRepoRegistry public repoRegistry;\n\n    /// @notice Thrown if a setup is unauthorized and cannot be applied because of a missing permission of the associated DAO.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param caller The address (EOA or contract) that requested the application of a setup on the associated DAO.\n    /// @param permissionId The permission identifier.\n    /// @dev This is thrown if the `APPLY_INSTALLATION_PERMISSION_ID`, `APPLY_UPDATE_PERMISSION_ID`, or APPLY_UNINSTALLATION_PERMISSION_ID is missing.\n    error SetupApplicationUnauthorized(address dao, address caller, bytes32 permissionId);\n\n    /// @notice Thrown if a plugin is not upgradeable.\n    /// @param plugin The address of the plugin contract.\n    error PluginNonupgradeable(address plugin);\n\n    /// @notice Thrown if the upgrade of an `UUPSUpgradeable` proxy contract (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)) failed.\n    /// @param proxy The address of the proxy.\n    /// @param implementation The address of the implementation contract.\n    /// @param initData The initialization data to be passed to the upgradeable plugin contract via `upgradeToAndCall`.\n    error PluginProxyUpgradeFailed(address proxy, address implementation, bytes initData);\n\n    /// @notice Thrown if a contract does not support the `IPlugin` interface.\n    /// @param plugin The address of the contract.\n    error IPluginNotSupported(address plugin);\n\n    /// @notice Thrown if a plugin repository does not exist on the plugin repo registry.\n    error PluginRepoNonexistent();\n\n    /// @notice Thrown if a plugin setup was already prepared inidcated by the prepared setup ID.\n    /// @param preparedSetupId The prepared setup ID.\n    error SetupAlreadyPrepared(bytes32 preparedSetupId);\n\n    /// @notice Thrown if a prepared setup ID is not eligible to be applied. This can happen if another setup has been already applied or if the setup wasn't prepared in the first place.\n    /// @param preparedSetupId The prepared setup ID.\n    error SetupNotApplicable(bytes32 preparedSetupId);\n\n    /// @notice Thrown if the update version is invalid.\n    /// @param currentVersionTag The tag of the current version to update from.\n    /// @param newVersionTag The tag of the new version to update to.\n    error InvalidUpdateVersion(PluginRepo.Tag currentVersionTag, PluginRepo.Tag newVersionTag);\n\n    /// @notice Thrown if plugin is already installed and one tries to prepare or apply install on it.\n    error PluginAlreadyInstalled();\n\n    /// @notice Thrown if the applied setup ID resulting from the supplied setup payload does not match with the current applied setup ID.\n    /// @param currentAppliedSetupId The current applied setup ID with which the data in the supplied payload must match.\n    /// @param appliedSetupId The applied setup ID obtained from the data in the supplied setup payload.\n    error InvalidAppliedSetupId(bytes32 currentAppliedSetupId, bytes32 appliedSetupId);\n\n    /// @notice Emitted with a prepared plugin installation to store data relevant for the application step.\n    /// @param sender The sender that prepared the plugin installation.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param preparedSetupId The prepared setup ID obtained from the supplied data.\n    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.\n    /// @param versionTag The version tag of the plugin setup of the prepared installation.\n    /// @param data The bytes-encoded data containing the input parameters for the preparation as specified in the corresponding ABI on the version's metadata.\n    /// @param plugin The address of the plugin contract.\n    /// @param preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    event InstallationPrepared(\n        address indexed sender,\n        address indexed dao,\n        bytes32 preparedSetupId,\n        PluginRepo indexed pluginSetupRepo,\n        PluginRepo.Tag versionTag,\n        bytes data,\n        address plugin,\n        IPluginSetup.PreparedSetupData preparedSetupData\n    );\n\n    /// @notice Emitted after a plugin installation was applied.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param plugin The address of the plugin contract.\n    /// @param preparedSetupId The prepared setup ID.\n    /// @param appliedSetupId The applied setup ID.\n    event InstallationApplied(\n        address indexed dao,\n        address indexed plugin,\n        bytes32 preparedSetupId,\n        bytes32 appliedSetupId\n    );\n\n    /// @notice Emitted with a prepared plugin update to store data relevant for the application step.\n    /// @param sender The sender that prepared the plugin update.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param preparedSetupId The prepared setup ID.\n    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.\n    /// @param versionTag The version tag of the plugin setup of the prepared update.\n    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.\n    /// @param preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    /// @param initData The initialization data to be passed to the upgradeable plugin contract.\n    event UpdatePrepared(\n        address indexed sender,\n        address indexed dao,\n        bytes32 preparedSetupId,\n        PluginRepo indexed pluginSetupRepo,\n        PluginRepo.Tag versionTag,\n        IPluginSetup.SetupPayload setupPayload,\n        IPluginSetup.PreparedSetupData preparedSetupData,\n        bytes initData\n    );\n\n    /// @notice Emitted after a plugin update was applied.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param plugin The address of the plugin contract.\n    /// @param preparedSetupId The prepared setup ID.\n    /// @param appliedSetupId The applied setup ID.\n    event UpdateApplied(\n        address indexed dao,\n        address indexed plugin,\n        bytes32 preparedSetupId,\n        bytes32 appliedSetupId\n    );\n\n    /// @notice Emitted with a prepared plugin uninstallation to store data relevant for the application step.\n    /// @param sender The sender that prepared the plugin uninstallation.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param preparedSetupId The prepared setup ID.\n    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.\n    /// @param versionTag The version tag of the plugin to used for install preparation.\n    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.\n    /// @param permissions The list of multi-targeted permission operations to be applied to the installing DAO.\n    event UninstallationPrepared(\n        address indexed sender,\n        address indexed dao,\n        bytes32 preparedSetupId,\n        PluginRepo indexed pluginSetupRepo,\n        PluginRepo.Tag versionTag,\n        IPluginSetup.SetupPayload setupPayload,\n        PermissionLib.MultiTargetPermission[] permissions\n    );\n\n    /// @notice Emitted after a plugin installation was applied.\n    /// @param dao The address of the DAO to which the plugin belongs.\n    /// @param plugin The address of the plugin contract.\n    /// @param preparedSetupId The prepared setup ID.\n    event UninstallationApplied(\n        address indexed dao,\n        address indexed plugin,\n        bytes32 preparedSetupId\n    );\n\n    /// @notice A modifier to check if a caller has the permission to apply a prepared setup.\n    /// @param _dao The address of the DAO.\n    /// @param _permissionId The permission identifier.\n    modifier canApply(address _dao, bytes32 _permissionId) {\n        _canApply(_dao, _permissionId);\n        _;\n    }\n\n    /// @notice Constructs the plugin setup processor by setting the associated plugin repo registry.\n    /// @param _repoRegistry The plugin repo registry contract.\n    constructor(PluginRepoRegistry _repoRegistry) {\n        repoRegistry = _repoRegistry;\n    }\n\n    /// @notice Prepares the installation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _params The struct containing the parameters for the `prepareInstallation` function.\n    /// @return plugin The prepared plugin contract address.\n    /// @return preparedSetupData The data struct containing the array of helper contracts and permissions that the setup has prepared.\n    function prepareInstallation(\n        address _dao,\n        PrepareInstallationParams calldata _params\n    ) external returns (address plugin, IPluginSetup.PreparedSetupData memory preparedSetupData) {\n        PluginRepo pluginSetupRepo = _params.pluginSetupRef.pluginSetupRepo;\n\n        // Check that the plugin repository exists on the plugin repo registry.\n        if (!repoRegistry.entries(address(pluginSetupRepo))) {\n            revert PluginRepoNonexistent();\n        }\n\n        // reverts if not found\n        PluginRepo.Version memory version = pluginSetupRepo.getVersion(\n            _params.pluginSetupRef.versionTag\n        );\n\n        // Prepare the installation\n        (plugin, preparedSetupData) = PluginSetup(version.pluginSetup).prepareInstallation(\n            _dao,\n            _params.data\n        );\n\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, plugin);\n\n        bytes32 preparedSetupId = _getPreparedSetupId(\n            _params.pluginSetupRef,\n            hashPermissions(preparedSetupData.permissions),\n            hashHelpers(preparedSetupData.helpers),\n            bytes(\"\"),\n            PreparationType.Installation\n        );\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        // Check if this plugin is already installed.\n        if (pluginState.currentAppliedSetupId != bytes32(0)) {\n            revert PluginAlreadyInstalled();\n        }\n\n        // Check if this setup has already been prepared before and is pending.\n        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {\n            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});\n        }\n\n        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;\n\n        emit InstallationPrepared({\n            sender: msg.sender,\n            dao: _dao,\n            preparedSetupId: preparedSetupId,\n            pluginSetupRepo: pluginSetupRepo,\n            versionTag: _params.pluginSetupRef.versionTag,\n            data: _params.data,\n            plugin: plugin,\n            preparedSetupData: preparedSetupData\n        });\n\n        return (plugin, preparedSetupData);\n    }\n\n    /// @notice Applies the permissions of a prepared installation to a DAO.\n    /// @param _dao The address of the installing DAO.\n    /// @param _params The struct containing the parameters for the `applyInstallation` function.\n    function applyInstallation(\n        address _dao,\n        ApplyInstallationParams calldata _params\n    ) external canApply(_dao, APPLY_INSTALLATION_PERMISSION_ID) {\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        bytes32 preparedSetupId = _getPreparedSetupId(\n            _params.pluginSetupRef,\n            hashPermissions(_params.permissions),\n            _params.helpersHash,\n            bytes(\"\"),\n            PreparationType.Installation\n        );\n\n        // Check if this plugin is already installed.\n        if (pluginState.currentAppliedSetupId != bytes32(0)) {\n            revert PluginAlreadyInstalled();\n        }\n\n        validatePreparedSetupId(pluginInstallationId, preparedSetupId);\n\n        bytes32 appliedSetupId = _getAppliedSetupId(_params.pluginSetupRef, _params.helpersHash);\n\n        pluginState.currentAppliedSetupId = appliedSetupId;\n        pluginState.blockNumber = block.number;\n\n        // Process the permissions, which requires the `ROOT_PERMISSION_ID` from the installing DAO.\n        if (_params.permissions.length > 0) {\n            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);\n        }\n\n        emit InstallationApplied({\n            dao: _dao,\n            plugin: _params.plugin,\n            preparedSetupId: preparedSetupId,\n            appliedSetupId: appliedSetupId\n        });\n    }\n\n    /// @notice Prepares the update of an UUPS upgradeable plugin.\n    /// @param _dao The address of the DAO For which preparation of update happens.\n    /// @param _params The struct containing the parameters for the `prepareUpdate` function.\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied\n    /// @return preparedSetupData The data struct containing the array of helper contracts and permissions that the setup has prepared.\n    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happend) on which the update is prepared for.\n    function prepareUpdate(\n        address _dao,\n        PrepareUpdateParams calldata _params\n    )\n        external\n        returns (bytes memory initData, IPluginSetup.PreparedSetupData memory preparedSetupData)\n    {\n        if (\n            _params.currentVersionTag.release != _params.newVersionTag.release ||\n            _params.currentVersionTag.build >= _params.newVersionTag.build\n        ) {\n            revert InvalidUpdateVersion({\n                currentVersionTag: _params.currentVersionTag,\n                newVersionTag: _params.newVersionTag\n            });\n        }\n\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.setupPayload.plugin);\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        bytes32 currentHelpersHash = hashHelpers(_params.setupPayload.currentHelpers);\n\n        bytes32 appliedSetupId = _getAppliedSetupId(\n            PluginSetupRef(_params.currentVersionTag, _params.pluginSetupRepo),\n            currentHelpersHash\n        );\n\n        // The following check implicitly confirms that plugin is currently installed.\n        // Otherwise, `currentAppliedSetupId` would not be set.\n        if (pluginState.currentAppliedSetupId != appliedSetupId) {\n            revert InvalidAppliedSetupId({\n                currentAppliedSetupId: pluginState.currentAppliedSetupId,\n                appliedSetupId: appliedSetupId\n            });\n        }\n\n        PluginRepo.Version memory currentVersion = _params.pluginSetupRepo.getVersion(\n            _params.currentVersionTag\n        );\n\n        PluginRepo.Version memory newVersion = _params.pluginSetupRepo.getVersion(\n            _params.newVersionTag\n        );\n\n        bytes32 preparedSetupId;\n\n        // If the current and new plugin setup are identical, this is an UI update.\n        // In this case, the permission hash is set to the empty array hash and the `prepareUpdate` call is skipped to avoid side effects.\n        if (currentVersion.pluginSetup == newVersion.pluginSetup) {\n            preparedSetupId = _getPreparedSetupId(\n                PluginSetupRef(_params.newVersionTag, _params.pluginSetupRepo),\n                EMPTY_ARRAY_HASH,\n                currentHelpersHash,\n                bytes(\"\"),\n                PreparationType.Update\n            );\n\n            // Because UI updates do not change the plugin functionality, the array of helpers\n            // associated with this plugin version `preparedSetupData.helpers` and being returned must\n            // equal `_params.setupPayload.currentHelpers` returned by the previous setup step (installation or update )\n            // that this update is transitioning from.\n            preparedSetupData.helpers = _params.setupPayload.currentHelpers;\n        } else {\n            // Check that plugin is `PluginUUPSUpgradable`.\n            if (!_params.setupPayload.plugin.supportsInterface(type(IPlugin).interfaceId)) {\n                revert IPluginNotSupported({plugin: _params.setupPayload.plugin});\n            }\n            if (IPlugin(_params.setupPayload.plugin).pluginType() != IPlugin.PluginType.UUPS) {\n                revert PluginNonupgradeable({plugin: _params.setupPayload.plugin});\n            }\n\n            // Prepare the update.\n            (initData, preparedSetupData) = PluginSetup(newVersion.pluginSetup).prepareUpdate(\n                _dao,\n                _params.currentVersionTag.build,\n                _params.setupPayload\n            );\n\n            preparedSetupId = _getPreparedSetupId(\n                PluginSetupRef(_params.newVersionTag, _params.pluginSetupRepo),\n                hashPermissions(preparedSetupData.permissions),\n                hashHelpers(preparedSetupData.helpers),\n                initData,\n                PreparationType.Update\n            );\n        }\n\n        // Check if this setup has already been prepared before and is pending.\n        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {\n            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});\n        }\n\n        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;\n\n        // Avoid stack too deep.\n        emitPrepareUpdateEvent(_dao, preparedSetupId, _params, preparedSetupData, initData);\n\n        return (initData, preparedSetupData);\n    }\n\n    /// @notice Applies the permissions of a prepared update of an UUPS upgradeable proxy contract to a DAO.\n    /// @param _dao The address of the updating DAO.\n    /// @param _params The struct containing the parameters for the `applyInstallation` function.\n    function applyUpdate(\n        address _dao,\n        ApplyUpdateParams calldata _params\n    ) external canApply(_dao, APPLY_UPDATE_PERMISSION_ID) {\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        bytes32 preparedSetupId = _getPreparedSetupId(\n            _params.pluginSetupRef,\n            hashPermissions(_params.permissions),\n            _params.helpersHash,\n            _params.initData,\n            PreparationType.Update\n        );\n\n        validatePreparedSetupId(pluginInstallationId, preparedSetupId);\n\n        bytes32 appliedSetupId = _getAppliedSetupId(_params.pluginSetupRef, _params.helpersHash);\n\n        pluginState.blockNumber = block.number;\n        pluginState.currentAppliedSetupId = appliedSetupId;\n\n        PluginRepo.Version memory version = _params.pluginSetupRef.pluginSetupRepo.getVersion(\n            _params.pluginSetupRef.versionTag\n        );\n\n        address currentImplementation = PluginUUPSUpgradeable(_params.plugin).implementation();\n        address newImplementation = PluginSetup(version.pluginSetup).implementation();\n\n        if (currentImplementation != newImplementation) {\n            _upgradeProxy(_params.plugin, newImplementation, _params.initData);\n        }\n\n        // Process the permissions, which requires the `ROOT_PERMISSION_ID` from the updating DAO.\n        if (_params.permissions.length > 0) {\n            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);\n        }\n\n        emit UpdateApplied({\n            dao: _dao,\n            plugin: _params.plugin,\n            preparedSetupId: preparedSetupId,\n            appliedSetupId: appliedSetupId\n        });\n    }\n\n    /// @notice Prepares the uninstallation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _params The struct containing the parameters for the `prepareUninstallation` function.\n    /// @return permissions The list of multi-targeted permission operations to be applied to the uninstalling DAO.\n    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happend) on which the uninstallation was prepared for.\n    function prepareUninstallation(\n        address _dao,\n        PrepareUninstallationParams calldata _params\n    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions) {\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.setupPayload.plugin);\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        bytes32 appliedSetupId = _getAppliedSetupId(\n            _params.pluginSetupRef,\n            hashHelpers(_params.setupPayload.currentHelpers)\n        );\n\n        if (pluginState.currentAppliedSetupId != appliedSetupId) {\n            revert InvalidAppliedSetupId({\n                currentAppliedSetupId: pluginState.currentAppliedSetupId,\n                appliedSetupId: appliedSetupId\n            });\n        }\n\n        PluginRepo.Version memory version = _params.pluginSetupRef.pluginSetupRepo.getVersion(\n            _params.pluginSetupRef.versionTag\n        );\n\n        permissions = PluginSetup(version.pluginSetup).prepareUninstallation(\n            _dao,\n            _params.setupPayload\n        );\n\n        bytes32 preparedSetupId = _getPreparedSetupId(\n            _params.pluginSetupRef,\n            hashPermissions(permissions),\n            ZERO_BYTES_HASH,\n            bytes(\"\"),\n            PreparationType.Uninstallation\n        );\n\n        // Check if this setup has already been prepared before and is pending.\n        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {\n            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});\n        }\n\n        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;\n\n        emit UninstallationPrepared({\n            sender: msg.sender,\n            dao: _dao,\n            preparedSetupId: preparedSetupId,\n            pluginSetupRepo: _params.pluginSetupRef.pluginSetupRepo,\n            versionTag: _params.pluginSetupRef.versionTag,\n            setupPayload: _params.setupPayload,\n            permissions: permissions\n        });\n    }\n\n    /// @notice Applies the permissions of a prepared uninstallation to a DAO.\n    /// @param _dao The address of the DAO.\n    /// @param _dao The address of the installing DAO.\n    /// @param _params The struct containing the parameters for the `applyUninstallation` function.\n    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happend) on which the uninstallation was prepared for.\n    function applyUninstallation(\n        address _dao,\n        ApplyUninstallationParams calldata _params\n    ) external canApply(_dao, APPLY_UNINSTALLATION_PERMISSION_ID) {\n        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);\n\n        PluginState storage pluginState = states[pluginInstallationId];\n\n        bytes32 preparedSetupId = _getPreparedSetupId(\n            _params.pluginSetupRef,\n            hashPermissions(_params.permissions),\n            ZERO_BYTES_HASH,\n            bytes(\"\"),\n            PreparationType.Uninstallation\n        );\n\n        validatePreparedSetupId(pluginInstallationId, preparedSetupId);\n\n        // Since the plugin is uninstalled, only the current block number must be updated.\n        pluginState.blockNumber = block.number;\n        pluginState.currentAppliedSetupId = bytes32(0);\n\n        // Process the permissions, which requires the `ROOT_PERMISSION_ID` from the uninstalling DAO.\n        if (_params.permissions.length > 0) {\n            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);\n        }\n\n        emit UninstallationApplied({\n            dao: _dao,\n            plugin: _params.plugin,\n            preparedSetupId: preparedSetupId\n        });\n    }\n\n    /// @notice Validates that a setup ID can be applied for `applyInstallation`, `applyUpdate`, or `applyUninstallation`.\n    /// @param pluginInstallationId The plugin installation ID obtained from the hash of `abi.encode(daoAddress, pluginAddress)`.\n    /// @param preparedSetupId The prepared setup ID to be validated.\n    /// @dev If the block number stored in `states[pluginInstallationId].blockNumber` exceeds the one stored in `pluginState.preparedSetupIdToBlockNumber[preparedSetupId]`, the prepared setup with `preparedSetupId` is outdated and not applicable anymore.\n    function validatePreparedSetupId(\n        bytes32 pluginInstallationId,\n        bytes32 preparedSetupId\n    ) public view {\n        PluginState storage pluginState = states[pluginInstallationId];\n        if (pluginState.blockNumber >= pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {\n            revert SetupNotApplicable({preparedSetupId: preparedSetupId});\n        }\n    }\n\n    /// @notice Upgrades a UUPS upgradeable proxy contract (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @param _proxy The address of the proxy.\n    /// @param _implementation The address of the implementation contract.\n    /// @param _initData The initialization data to be passed to the upgradeable plugin contract via `upgradeToAndCall`.\n    function _upgradeProxy(\n        address _proxy,\n        address _implementation,\n        bytes memory _initData\n    ) private {\n        if (_initData.length > 0) {\n            try\n                PluginUUPSUpgradeable(_proxy).upgradeToAndCall(_implementation, _initData)\n            {} catch Error(string memory reason) {\n                revert(reason);\n            } catch (bytes memory /*lowLevelData*/) {\n                revert PluginProxyUpgradeFailed({\n                    proxy: _proxy,\n                    implementation: _implementation,\n                    initData: _initData\n                });\n            }\n        } else {\n            try PluginUUPSUpgradeable(_proxy).upgradeTo(_implementation) {} catch Error(\n                string memory reason\n            ) {\n                revert(reason);\n            } catch (bytes memory /*lowLevelData*/) {\n                revert PluginProxyUpgradeFailed({\n                    proxy: _proxy,\n                    implementation: _implementation,\n                    initData: _initData\n                });\n            }\n        }\n    }\n\n    /// @notice Checks if a caller has the permission to apply a setup.\n    /// @param _dao The address of the applying DAO.\n    /// @param _permissionId The permission ID.\n    function _canApply(address _dao, bytes32 _permissionId) private view {\n        if (\n            msg.sender != _dao &&\n            !DAO(payable(_dao)).hasPermission(address(this), msg.sender, _permissionId, bytes(\"\"))\n        ) {\n            revert SetupApplicationUnauthorized({\n                dao: _dao,\n                caller: msg.sender,\n                permissionId: _permissionId\n            });\n        }\n    }\n\n    /// @notice A helper to emit the `UpdatePrepared` event from the supplied, structured data.\n    /// @param _dao The address of the updating DAO.\n    /// @param _preparedSetupId The prepared setup ID.\n    /// @param _params The struct containing the parameters for the `prepareUpdate` function.\n    /// @param _preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    /// @param _initData The initialization data to be passed to upgradeable contracts when the update is applied\n    /// @dev This functions exists to avoid stack-too-deep errors.\n    function emitPrepareUpdateEvent(\n        address _dao,\n        bytes32 _preparedSetupId,\n        PrepareUpdateParams calldata _params,\n        IPluginSetup.PreparedSetupData memory _preparedSetupData,\n        bytes memory _initData\n    ) private {\n        emit UpdatePrepared({\n            sender: msg.sender,\n            dao: _dao,\n            preparedSetupId: _preparedSetupId,\n            pluginSetupRepo: _params.pluginSetupRepo,\n            versionTag: _params.newVersionTag,\n            setupPayload: _params.setupPayload,\n            preparedSetupData: _preparedSetupData,\n            initData: _initData\n        });\n    }\n}\n"
    },
    "@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC1822ProxiableUpgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IDAO} from \"../dao/IDAO.sol\";\nimport {DaoAuthorizableUpgradeable} from \"./dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IPlugin} from \"./IPlugin.sol\";\n\n/// @title PluginUUPSUpgradeable\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract, upgradeable contract to inherit from when creating a plugin being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\nabstract contract PluginUUPSUpgradeable is\n    IPlugin,\n    ERC165Upgradeable,\n    UUPSUpgradeable,\n    DaoAuthorizableUpgradeable\n{\n    // NOTE: When adding new state variables to the contract, the size of `_gap` has to be adapted below as well.\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.UUPS;\n    }\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_PLUGIN_PERMISSION_ID = keccak256(\"UPGRADE_PLUGIN_PERMISSION\");\n\n    /// @notice Initializes the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    function __PluginUUPSUpgradeable_init(IDAO _dao) internal virtual onlyInitializing {\n        __DaoAuthorizableUpgradeable_init(_dao);\n    }\n\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            _interfaceId == type(IERC1822ProxiableUpgradeable).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns the address of the implementation contract in the [proxy storage slot](https://eips.ethereum.org/EIPS/eip-1967) slot the [UUPS proxy](https://eips.ethereum.org/EIPS/eip-1822) is pointing to.\n    /// @return The address of the implementation contract.\n    function implementation() public view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_PLUGIN_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_PLUGIN_PERMISSION_ID) {}\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n"
    },
    "@aragon/osx/core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport {IDAO} from \"../../dao/IDAO.sol\";\nimport {_auth} from \"../../utils/auth.sol\";\n\n/// @title DaoAuthorizableUpgradeable\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract contract providing a meta-transaction compatible modifier for upgradeable or cloneable contracts to authorize function calls through an associated DAO.\n/// @dev Make sure to call `__DaoAuthorizableUpgradeable_init` during initialization of the inheriting contract.\nabstract contract DaoAuthorizableUpgradeable is ContextUpgradeable {\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\n    IDAO private dao_;\n\n    /// @notice Initializes the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    function __DaoAuthorizableUpgradeable_init(IDAO _dao) internal onlyInitializing {\n        dao_ = _dao;\n    }\n\n    /// @notice Returns the DAO contract.\n    /// @return The DAO contract.\n    function dao() public view returns (IDAO) {\n        return dao_;\n    }\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through the associated DAO's permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(dao_, address(this), _msgSender(), _permissionId, _msgData());\n        _;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/utils/auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {IDAO} from \"../dao/IDAO.sol\";\n\n/// @notice Thrown if a call is unauthorized in the associated DAO.\n/// @param dao The associated DAO.\n/// @param where The context in which the authorization reverted.\n/// @param who The address (EOA or contract) missing the permission.\n/// @param permissionId The permission identifier.\nerror DaoUnauthorized(address dao, address where, address who, bytes32 permissionId);\n\n/// @notice A free function checking if a caller is granted permissions on a target contract via a permission identifier that redirects the approval to a `PermissionCondition` if this was specified in the setup.\n/// @param _where The address of the target contract for which `who` recieves permission.\n/// @param _who The address (EOA or contract) owning the permission.\n/// @param _permissionId The permission identifier.\n/// @param _data The optional data passed to the `PermissionCondition` registered.\nfunction _auth(\n    IDAO _dao,\n    address _where,\n    address _who,\n    bytes32 _permissionId,\n    bytes calldata _data\n) view {\n    if (!_dao.hasPermission(_where, _who, _permissionId, _data))\n        revert DaoUnauthorized({\n            dao: address(_dao),\n            where: _where,\n            who: _who,\n            permissionId: _permissionId\n        });\n}\n"
    },
    "@aragon/osx/core/plugin/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @title IPlugin\n/// @author Aragon Association - 2022-2023\n/// @notice An interface defining the traits of a plugin.\ninterface IPlugin {\n    enum PluginType {\n        UUPS,\n        Cloneable,\n        Constructable\n    }\n\n    /// @notice returns the plugin's type\n    function pluginType() external view returns (PluginType);\n}\n"
    },
    "@aragon/osx/framework/plugin/repo/PluginRepoRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\nimport {ENSSubdomainRegistrar} from \"../../utils/ens/ENSSubdomainRegistrar.sol\";\nimport {InterfaceBasedRegistry} from \"../../utils/InterfaceBasedRegistry.sol\";\nimport {isSubdomainValid} from \"../../utils/RegistryUtils.sol\";\nimport {IPluginRepo} from \"./IPluginRepo.sol\";\n\n/// @title PluginRepoRegistry\n/// @author Aragon Association - 2022-2023\n/// @notice This contract maintains an address-based registery of plugin repositories in the Aragon App DAO framework.\ncontract PluginRepoRegistry is InterfaceBasedRegistry {\n    /// @notice The ID of the permission required to call the `register` function.\n    bytes32 public constant REGISTER_PLUGIN_REPO_PERMISSION_ID =\n        keccak256(\"REGISTER_PLUGIN_REPO_PERMISSION\");\n\n    /// @notice The ENS subdomain registrar registering the PluginRepo subdomains.\n    ENSSubdomainRegistrar public subdomainRegistrar;\n\n    /// @notice Emitted if a new plugin repository is registered.\n    /// @param subdomain The subdomain of the plugin repository.\n    /// @param pluginRepo The address of the plugin repository.\n    event PluginRepoRegistered(string subdomain, address pluginRepo);\n\n    /// @notice Thrown if the plugin subdomain doesn't match the regex `[0-9a-z\\-]`\n    error InvalidPluginSubdomain(string subdomain);\n\n    /// @notice Thrown if the plugin repository subdomain is empty.\n    error EmptyPluginRepoSubdomain();\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract by setting calling the `InterfaceBasedRegistry` base class initialize method.\n    /// @param _dao The address of the managing DAO.\n    /// @param _subdomainRegistrar The `ENSSubdomainRegistrar` where `ENS` subdomain will be registered.\n    function initialize(IDAO _dao, ENSSubdomainRegistrar _subdomainRegistrar) external initializer {\n        bytes4 pluginRepoInterfaceId = type(IPluginRepo).interfaceId;\n        __InterfaceBasedRegistry_init(_dao, pluginRepoInterfaceId);\n\n        subdomainRegistrar = _subdomainRegistrar;\n    }\n\n    /// @notice Registers a plugin repository with a subdomain and address.\n    /// @param subdomain The subdomain of the PluginRepo.\n    /// @param pluginRepo The address of the PluginRepo contract.\n    function registerPluginRepo(\n        string calldata subdomain,\n        address pluginRepo\n    ) external auth(REGISTER_PLUGIN_REPO_PERMISSION_ID) {\n        if (!(bytes(subdomain).length > 0)) {\n            revert EmptyPluginRepoSubdomain();\n        }\n\n        if (!isSubdomainValid(subdomain)) {\n            revert InvalidPluginSubdomain({subdomain: subdomain});\n        }\n\n        bytes32 labelhash = keccak256(bytes(subdomain));\n        subdomainRegistrar.registerSubnode(labelhash, pluginRepo);\n\n        _register(pluginRepo);\n\n        emit PluginRepoRegistered(subdomain, pluginRepo);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/framework/utils/ens/ENSSubdomainRegistrar.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/Resolver.sol\";\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {DaoAuthorizableUpgradeable} from \"../../../core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\n\n/// @title ENSSubdomainRegistrar\n/// @author Aragon Association - 2022-2023\n/// @notice This contract registers ENS subdomains under a parent domain specified in the initialization process and maintains ownership of the subdomain since only the resolver address is set. This contract must either be the domain node owner or an approved operator of the node owner. The default resolver being used is the one specified in the parent domain.\ncontract ENSSubdomainRegistrar is UUPSUpgradeable, DaoAuthorizableUpgradeable {\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_REGISTRAR_PERMISSION_ID =\n        keccak256(\"UPGRADE_REGISTRAR_PERMISSION\");\n\n    /// @notice The ID of the permission required to call the `registerSubnode` and `setDefaultResolver` function.\n    bytes32 public constant REGISTER_ENS_SUBDOMAIN_PERMISSION_ID =\n        keccak256(\"REGISTER_ENS_SUBDOMAIN_PERMISSION\");\n\n    /// @notice The ENS registry contract\n    ENS public ens;\n\n    /// @notice The namehash of the domain on which subdomains are registered.\n    bytes32 public node;\n\n    /// @notice The address of the ENS resolver resolving the names to an address.\n    address public resolver;\n\n    /// @notice Thrown if the subnode is already registered.\n    /// @param subnode The subnode namehash.\n    /// @param nodeOwner The node owner address.\n    error AlreadyRegistered(bytes32 subnode, address nodeOwner);\n\n    /// @notice Thrown if node's resolver is invalid.\n    /// @param node The node namehash.\n    /// @param resolver The node resolver address.\n    error InvalidResolver(bytes32 node, address resolver);\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the component by\n    /// - checking that the contract is the domain node owner or an approved operator\n    /// - initializing the underlying component\n    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID\n    /// - setting the ENS contract, the domain node hash, and resolver.\n    /// @param _managingDao The interface of the DAO managing the components permissions.\n    /// @param _ens The interface of the ENS registry to be used.\n    /// @param _node The ENS parent domain node under which the subdomains are to be registered.\n    function initialize(IDAO _managingDao, ENS _ens, bytes32 _node) external initializer {\n        __DaoAuthorizableUpgradeable_init(_managingDao);\n\n        ens = _ens;\n        node = _node;\n\n        address nodeResolver = ens.resolver(_node);\n\n        if (nodeResolver == address(0)) {\n            revert InvalidResolver({node: _node, resolver: nodeResolver});\n        }\n\n        resolver = nodeResolver;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_REGISTRAR_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_REGISTRAR_PERMISSION_ID) {}\n\n    /// @notice Registers a new subdomain with this registrar as the owner and set the target address in the resolver.\n    /// @dev It reverts with no message if this contract isn't the owner nor an approved operator for the given node.\n    /// @param _label The labelhash of the subdomain name.\n    /// @param _targetAddress The address to which the subdomain resolves.\n    function registerSubnode(\n        bytes32 _label,\n        address _targetAddress\n    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, _label));\n        address currentOwner = ens.owner(subnode);\n\n        if (currentOwner != address(0)) {\n            revert AlreadyRegistered(subnode, currentOwner);\n        }\n\n        ens.setSubnodeOwner(node, _label, address(this));\n        ens.setResolver(subnode, resolver);\n        Resolver(resolver).setAddr(subnode, _targetAddress);\n    }\n\n    /// @notice Sets the default resolver contract address that the subdomains being registered will use.\n    /// @param _resolver The resolver contract to be used.\n    function setDefaultResolver(\n        address _resolver\n    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {\n        if (_resolver == address(0)) {\n            revert InvalidResolver({node: node, resolver: _resolver});\n        }\n\n        resolver = _resolver;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n"
    },
    "@aragon/osx/framework/utils/InterfaceBasedRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport {DaoAuthorizableUpgradeable} from \"../../core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IDAO} from \"../../core/dao/IDAO.sol\";\n\n/// @title InterfaceBasedRegistry\n/// @author Aragon Association - 2022-2023\n/// @notice An [ERC-165](https://eips.ethereum.org/EIPS/eip-165)-based registry for contracts\nabstract contract InterfaceBasedRegistry is UUPSUpgradeable, DaoAuthorizableUpgradeable {\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_REGISTRY_PERMISSION_ID =\n        keccak256(\"UPGRADE_REGISTRY_PERMISSION\");\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID that the target contracts being registered must support.\n    bytes4 public targetInterfaceId;\n\n    /// @notice The mapping containing the registry entries returning true for registererd contract addresses.\n    mapping(address => bool) public entries;\n\n    /// @notice Thrown if the contract is already registered.\n    /// @param registrant The address of the contract to be registered.\n    error ContractAlreadyRegistered(address registrant);\n\n    /// @notice Thrown if the contract does not support the required interface.\n    /// @param registrant The address of the contract to be registered.\n    error ContractInterfaceInvalid(address registrant);\n\n    /// @notice Thrown if the contract do not support ERC165.\n    /// @param registrant The address of the contract.\n    error ContractERC165SupportInvalid(address registrant);\n\n    /// @notice Initializes the component.\n    /// @dev This is required for the UUPS upgradability pattern.\n    /// @param _managingDao The interface of the DAO managing the components permissions.\n    /// @param _targetInterfaceId The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface id of the contracts to be registered.\n    function __InterfaceBasedRegistry_init(\n        IDAO _managingDao,\n        bytes4 _targetInterfaceId\n    ) internal virtual onlyInitializing {\n        __DaoAuthorizableUpgradeable_init(_managingDao);\n\n        targetInterfaceId = _targetInterfaceId;\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_REGISTRY_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_REGISTRY_PERMISSION_ID) {}\n\n    /// @notice Register an [ERC-165](https://eips.ethereum.org/EIPS/eip-165) contract address.\n    /// @dev The managing DAO needs to grant REGISTER_PERMISSION_ID to registrar.\n    /// @param _registrant The address of an [ERC-165](https://eips.ethereum.org/EIPS/eip-165) contract.\n    function _register(address _registrant) internal {\n        if (entries[_registrant]) {\n            revert ContractAlreadyRegistered({registrant: _registrant});\n        }\n\n        // Will revert if address is not a contract or doesn't fully support targetInterfaceId + ERC165.\n        if (!_registrant.supportsInterface(targetInterfaceId)) {\n            revert ContractInterfaceInvalid(_registrant);\n        }\n\n        entries[_registrant] = true;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[48] private __gap;\n}\n"
    },
    "@aragon/osx/framework/utils/RegistryUtils.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\n/// @notice Validates that a subdomain name is composed only from characters in the allowed character set:\n/// - the lowercase letters `a-z`\n/// - the digits `0-9`\n/// - the hyphen `-`\n/// @dev This function allows empty (zero-length) subdomains. If this should not be allowed, make sure to add a respective check when using this function in your code.\n/// @param subDomain The name of the DAO.\n/// @return `true` if the name is valid or `false` if at least one char is invalid.\n/// @dev Aborts on the first invalid char found.\nfunction isSubdomainValid(string calldata subDomain) pure returns (bool) {\n    bytes calldata nameBytes = bytes(subDomain);\n    uint256 nameLength = nameBytes.length;\n    for (uint256 i; i < nameLength; i++) {\n        uint8 char = uint8(nameBytes[i]);\n\n        // if char is between a-z\n        if (char > 96 && char < 123) {\n            continue;\n        }\n\n        // if char is between 0-9\n        if (char > 47 && char < 58) {\n            continue;\n        }\n\n        // if char is -\n        if (char == 45) {\n            continue;\n        }\n\n        // invalid if one char doesn't work with the rules above\n        return false;\n    }\n    return true;\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/PluginSetupProcessorHelpers.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {PluginRepo} from \"../repo/PluginRepo.sol\";\nimport {PluginSetup} from \"./PluginSetup.sol\";\n\n/// @notice The struct containin a reference to a plugin setup by specifying the containing plugin repository and the associated version tag.\n/// @param versionTag The tag associated with the plugin setup version.\n/// @param pluginSetupRepo The plugin setup repository.\nstruct PluginSetupRef {\n    PluginRepo.Tag versionTag;\n    PluginRepo pluginSetupRepo;\n}\n\n/// @notice The different types describing a prepared setup.\n/// @param None The default indicating the lack of a preparation type.\n/// @param Installation The prepared setup installs a new plugin.\n/// @param Update The prepared setup updates an existing plugin.\n/// @param Uninstallation The prepared setup uninstalls an existing plugin.\nenum PreparationType {\n    None,\n    Installation,\n    Update,\n    Uninstallation\n}\n\n/// @notice Returns an ID for plugin installation by hashing the DAO and plugin address.\n/// @param _dao The address of the DAO conducting the setup.\n/// @param _plugin The plugin address.\nfunction _getPluginInstallationId(address _dao, address _plugin) pure returns (bytes32) {\n    return keccak256(abi.encode(_dao, _plugin));\n}\n\n/// @notice Returns an ID for prepared setup obtained from hashing characterizing elements.\n/// @param _pluginSetupRef The reference of the plugin setup containing plugin setup repo and version tag.\n/// @param _permissionsHash The hash of the permission operations requested by the setup.\n/// @param _helpersHash The hash of the helper contract addresses.\n/// @param _data The bytes-encoded initialize data for the upgrade that is returned by `prepareUpdate`.\n/// @param _preparationType The type of preparation the plugin is currently undergoing. Without this, it is possible to call `applyUpdate` even after `applyInstallation` is called.\n/// @return The prepared setup id.\nfunction _getPreparedSetupId(\n    PluginSetupRef memory _pluginSetupRef,\n    bytes32 _permissionsHash,\n    bytes32 _helpersHash,\n    bytes memory _data,\n    PreparationType _preparationType\n) pure returns (bytes32) {\n    return\n        keccak256(\n            abi.encode(\n                _pluginSetupRef.versionTag,\n                _pluginSetupRef.pluginSetupRepo,\n                _permissionsHash,\n                _helpersHash,\n                keccak256(_data),\n                _preparationType\n            )\n        );\n}\n\n/// @notice Returns an identifier for applied installations.\n/// @param _pluginSetupRef The reference of the plugin setup containing plugin setup repo and version tag.\n/// @param _helpersHash The hash of the helper contract addresses.\n/// @return The applied setup id.\nfunction _getAppliedSetupId(\n    PluginSetupRef memory _pluginSetupRef,\n    bytes32 _helpersHash\n) pure returns (bytes32) {\n    return\n        keccak256(\n            abi.encode(_pluginSetupRef.versionTag, _pluginSetupRef.pluginSetupRepo, _helpersHash)\n        );\n}\n\n/// @notice Returns a hash of an array of helper addresses (contracts or EOAs).\n/// @param _helpers The array of helper addresses (contracts or EOAs) to be hashed.\nfunction hashHelpers(address[] memory _helpers) pure returns (bytes32) {\n    return keccak256(abi.encode(_helpers));\n}\n\n/// @notice Returns a hash of an array of multi-targeted permission operations.\n/// @param _permissions The array of of multi-targeted permission operations.\n/// @return The hash of the array of permission operations.\nfunction hashPermissions(\n    PermissionLib.MultiTargetPermission[] memory _permissions\n) pure returns (bytes32) {\n    return keccak256(abi.encode(_permissions));\n}\n"
    },
    "@aragon/osx/framework/dao/DAORegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport {IDAO} from \"../../core/dao/IDAO.sol\";\nimport {ENSSubdomainRegistrar} from \"../utils/ens/ENSSubdomainRegistrar.sol\";\nimport {InterfaceBasedRegistry} from \"../utils/InterfaceBasedRegistry.sol\";\nimport {isSubdomainValid} from \"../utils/RegistryUtils.sol\";\n\n/// @title Register your unique DAO subdomain\n/// @author Aragon Association - 2022-2023\n/// @notice This contract provides the possiblity to register a DAO.\ncontract DAORegistry is InterfaceBasedRegistry {\n    /// @notice The ID of the permission required to call the `register` function.\n    bytes32 public constant REGISTER_DAO_PERMISSION_ID = keccak256(\"REGISTER_DAO_PERMISSION\");\n\n    /// @notice The ENS subdomain registrar registering the DAO subdomains.\n    ENSSubdomainRegistrar public subdomainRegistrar;\n\n    /// @notice Thrown if the DAO subdomain doesn't match the regex `[0-9a-z\\-]`\n    error InvalidDaoSubdomain(string subdomain);\n\n    /// @notice Emitted when a new DAO is registered.\n    /// @param dao The address of the DAO contract.\n    /// @param creator The address of the creator.\n    /// @param subdomain The DAO subdomain.\n    event DAORegistered(address indexed dao, address indexed creator, string subdomain);\n\n    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _managingDao the managing DAO address.\n    /// @param _subdomainRegistrar The `ENSSubdomainRegistrar` where `ENS` subdomain will be registered.\n    function initialize(\n        IDAO _managingDao,\n        ENSSubdomainRegistrar _subdomainRegistrar\n    ) external initializer {\n        __InterfaceBasedRegistry_init(_managingDao, type(IDAO).interfaceId);\n        subdomainRegistrar = _subdomainRegistrar;\n    }\n\n    /// @notice Registers a DAO by its address.\n    /// @dev A subdomain is unique within the Aragon DAO framework and can get stored here.\n    /// @param dao The address of the DAO contract.\n    /// @param creator The address of the creator.\n    /// @param subdomain The DAO subdomain.\n    function register(\n        IDAO dao,\n        address creator,\n        string calldata subdomain\n    ) external auth(REGISTER_DAO_PERMISSION_ID) {\n        address daoAddr = address(dao);\n\n        _register(daoAddr);\n\n        if ((bytes(subdomain).length > 0)) {\n            if (!isSubdomainValid(subdomain)) {\n                revert InvalidDaoSubdomain({subdomain: subdomain});\n            }\n\n            bytes32 labelhash = keccak256(bytes(subdomain));\n\n            subdomainRegistrar.registerSubnode(labelhash, daoAddr);\n        }\n\n        emit DAORegistered(daoAddr, creator, subdomain);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": ["id", "ast"]
      }
    }
  }
}
